{"file_contents":{"test_error_handling.py":{"content":"\"\"\"\nTest Script for Error Handling Features\nTests the enhanced error handling and recovery capabilities.\n\"\"\"\n\nimport streamlit as st\nimport pandas as pd\nimport json\nfrom pathlib import Path\nimport sys\nimport traceback\n\n# Add current directory to path\nsys.path.append('.')\n\n# Import the modules to test\ntry:\n    from error_handler import (\n        ErrorHandler, SafeOperation, error_handler,\n        validate_email_address, validate_file_size,\n        validate_template_syntax, create_diagnostic_report\n    )\n    print(\"‚úÖ Error handler imported successfully\")\nexcept Exception as e:\n    print(f\"‚ùå Failed to import error_handler: {e}\")\n    traceback.print_exc()\n\ntry:\n    from recovery_utils import (\n        SessionRecovery, ApplicationDiagnostics,\n        session_recovery\n    )\n    print(\"‚úÖ Recovery utils imported successfully\")\nexcept Exception as e:\n    print(f\"‚ùå Failed to import recovery_utils: {e}\")\n    traceback.print_exc()\n\ndef test_error_logging():\n    \"\"\"Test error logging functionality.\"\"\"\n    print(\"\\n=== Testing Error Logging ===\")\n    \n    try:\n        # Test logging different severity levels\n        test_error = ValueError(\"Test error for logging\")\n        error_record = error_handler.log_error(\n            test_error,\n            context=\"Test Context\",\n            user_message=\"This is a test error message\",\n            severity=\"ERROR\"\n        )\n        print(f\"‚úÖ Error logged: {error_record['user_message']}\")\n        \n        # Test getting recent errors\n        recent_errors = error_handler.get_recent_errors(5)\n        print(f\"‚úÖ Retrieved {len(recent_errors)} recent errors\")\n        \n        return True\n    except Exception as e:\n        print(f\"‚ùå Error logging test failed: {e}\")\n        return False\n\ndef test_validation_functions():\n    \"\"\"Test validation functions.\"\"\"\n    print(\"\\n=== Testing Validation Functions ===\")\n    \n    # Test email validation\n    test_cases = [\n        (\"user@example.com\", True),\n        (\"invalid.email\", False),\n        (\"user@example.com, admin@test.org\", True),\n        (\"[disabled@example.com]\", True),  # Bracketed emails are skipped\n        (\"\", False)\n    ]\n    \n    for email, expected_valid in test_cases:\n        is_valid, error_msg = validate_email_address(email)\n        if is_valid == expected_valid:\n            print(f\"‚úÖ Email validation correct for: {email[:30]}\")\n        else:\n            print(f\"‚ùå Email validation failed for: {email}\")\n    \n    # Test template syntax validation\n    template_tests = [\n        (\"Hello [Name], welcome to [Company]!\", True),\n        (\"Missing bracket [Name\", False),\n        (\"Empty placeholder []\", False),\n        (\"Valid [Conditional:Premium] content\", True)\n    ]\n    \n    for template, expected_valid in template_tests:\n        is_valid, errors = validate_template_syntax(template)\n        if is_valid == expected_valid:\n            print(f\"‚úÖ Template validation correct: {template[:30]}...\")\n        else:\n            print(f\"‚ùå Template validation failed: {template[:30]}...\")\n    \n    # Test file size validation\n    test_file = Path(\"test_file.tmp\")\n    try:\n        test_file.write_text(\"x\" * 1000)  # 1KB file\n        is_valid, error = validate_file_size(test_file, max_size_mb=0.001)\n        if not is_valid:\n            print(\"‚úÖ File size validation working\")\n        else:\n            print(\"‚ùå File size validation should have failed\")\n        test_file.unlink()\n    except Exception as e:\n        print(f\"‚ùå File size validation error: {e}\")\n\ndef test_backup_restore():\n    \"\"\"Test backup and restore functionality.\"\"\"\n    print(\"\\n=== Testing Backup/Restore ===\")\n    \n    try:\n        # Test backup creation\n        test_data = {\"test_key\": \"test_value\", \"count\": 42}\n        backup_file = error_handler.create_backup(\n            test_data,\n            \"test_backup\",\n            \"json\"\n        )\n        \n        if backup_file and backup_file.exists():\n            print(f\"‚úÖ Backup created: {backup_file}\")\n            \n            # Test restore\n            success, restored_data = error_handler.restore_backup(backup_file)\n            if success and restored_data == test_data:\n                print(\"‚úÖ Backup restored successfully\")\n            else:\n                print(\"‚ùå Backup restore failed or data mismatch\")\n        else:\n            print(\"‚ùå Backup creation failed\")\n        \n        # Test CSV backup\n        test_df = pd.DataFrame({\n            'Name': ['Alice', 'Bob'],\n            'Email': ['alice@example.com', 'bob@example.com']\n        })\n        \n        csv_backup = error_handler.create_backup(\n            test_df,\n            \"test_csv_backup\",\n            \"csv\"\n        )\n        \n        if csv_backup and csv_backup.exists():\n            print(f\"‚úÖ CSV backup created: {csv_backup}\")\n        else:\n            print(\"‚ùå CSV backup failed\")\n            \n    except Exception as e:\n        print(f\"‚ùå Backup/restore test failed: {e}\")\n        traceback.print_exc()\n\ndef test_session_recovery():\n    \"\"\"Test session recovery functionality.\"\"\"\n    print(\"\\n=== Testing Session Recovery ===\")\n    \n    try:\n        # Create mock session state\n        class MockSessionState:\n            def __init__(self):\n                self.template_text = \"Test template with [Name]\"\n                self.template_mode = \"plain\"\n                self.template_variables = [\"Name\"]\n                self.current_step = 3\n                self.excel_data = pd.DataFrame({\n                    'Name': ['Test User'],\n                    'Email': ['test@example.com']\n                })\n        \n        mock_state = MockSessionState()\n        \n        # Test auto-save\n        if session_recovery.auto_save_session(mock_state):\n            print(\"‚úÖ Session auto-saved successfully\")\n        else:\n            print(\"‚ùå Session auto-save failed\")\n        \n        # Test recovery\n        new_state = MockSessionState()\n        new_state.template_text = \"\"  # Clear data\n        \n        if session_recovery.recover_session(new_state):\n            if new_state.template_text == \"Test template with [Name]\":\n                print(\"‚úÖ Session recovered successfully\")\n            else:\n                print(\"‚ùå Session recovery data mismatch\")\n        else:\n            print(\"‚ùå Session recovery failed\")\n        \n        # Test export\n        export_file = session_recovery.export_session(mock_state)\n        if export_file and export_file.exists():\n            print(f\"‚úÖ Session exported: {export_file}\")\n        else:\n            print(\"‚ùå Session export failed\")\n            \n    except Exception as e:\n        print(f\"‚ùå Session recovery test failed: {e}\")\n        traceback.print_exc()\n\ndef test_diagnostics():\n    \"\"\"Test diagnostic functionality.\"\"\"\n    print(\"\\n=== Testing Diagnostics ===\")\n    \n    try:\n        diagnostics = ApplicationDiagnostics()\n        \n        # Test system requirements check\n        requirements = diagnostics.check_system_requirements()\n        print(f\"‚úÖ System requirements checked: Python {requirements['python_version']['current'][:10]}...\")\n        \n        # Test self-test\n        test_results = diagnostics.run_self_test()\n        passed = sum(1 for result in test_results.values() if result)\n        total = len(test_results)\n        print(f\"‚úÖ Self-test completed: {passed}/{total} tests passed\")\n        \n        # Test performance metrics\n        try:\n            metrics = diagnostics.get_performance_metrics()\n            if 'memory' in metrics:\n                print(f\"‚úÖ Performance metrics available\")\n            else:\n                print(\"‚ö†Ô∏è Performance metrics limited (psutil not installed)\")\n        except Exception:\n            print(\"‚ö†Ô∏è Performance metrics not available (psutil required)\")\n            \n    except Exception as e:\n        print(f\"‚ùå Diagnostics test failed: {e}\")\n        traceback.print_exc()\n\ndef test_error_report():\n    \"\"\"Test error report generation.\"\"\"\n    print(\"\\n=== Testing Error Report ===\")\n    \n    try:\n        # Generate some test errors\n        for i in range(3):\n            error_handler.log_error(\n                ValueError(f\"Test error {i+1}\"),\n                context=f\"Test Context {i+1}\",\n                severity=\"ERROR\" if i < 2 else \"WARNING\"\n            )\n        \n        # Generate report\n        report = error_handler.export_error_report()\n        \n        if \"EMAIL GENERATOR ERROR REPORT\" in report:\n            print(\"‚úÖ Error report generated\")\n            print(f\"   Report length: {len(report)} characters\")\n        else:\n            print(\"‚ùå Error report generation failed\")\n            \n    except Exception as e:\n        print(f\"‚ùå Error report test failed: {e}\")\n\ndef test_safe_operation_decorator():\n    \"\"\"Test the SafeOperation decorator.\"\"\"\n    print(\"\\n=== Testing SafeOperation Decorator ===\")\n    \n    try:\n        @SafeOperation(error_handler, \"Test Operation\")\n        def test_function(should_fail=False):\n            if should_fail:\n                raise ValueError(\"Intentional test error\")\n            return \"Success\"\n        \n        # Test successful operation\n        result = test_function(should_fail=False)\n        if result == \"Success\":\n            print(\"‚úÖ SafeOperation decorator - success case works\")\n        else:\n            print(\"‚ùå SafeOperation decorator - unexpected result\")\n        \n        # Test failed operation\n        result = test_function(should_fail=True)\n        if result is None:\n            print(\"‚úÖ SafeOperation decorator - handles errors gracefully\")\n        else:\n            print(\"‚ùå SafeOperation decorator - should return None on error\")\n            \n    except Exception as e:\n        print(f\"‚ùå SafeOperation decorator test failed: {e}\")\n\ndef main():\n    \"\"\"Run all tests.\"\"\"\n    print(\"=\" * 60)\n    print(\"TESTING ERROR HANDLING AND RECOVERY FEATURES\")\n    print(\"=\" * 60)\n    \n    # Run all tests\n    test_error_logging()\n    test_validation_functions()\n    test_backup_restore()\n    test_session_recovery()\n    test_diagnostics()\n    test_error_report()\n    test_safe_operation_decorator()\n    \n    print(\"\\n\" + \"=\" * 60)\n    print(\"TEST SUMMARY\")\n    print(\"=\" * 60)\n    \n    # Check if critical directories exist\n    critical_dirs = ['logs', 'backups', 'session_backups', 'templates', 'generated_emails']\n    for dir_name in critical_dirs:\n        dir_path = Path(dir_name)\n        if dir_path.exists():\n            print(f\"‚úÖ Directory exists: {dir_name}\")\n        else:\n            print(f\"‚ö†Ô∏è Directory missing: {dir_name} (will be created on first use)\")\n    \n    # Final diagnostic report\n    print(\"\\n\" + \"=\" * 60)\n    print(\"DIAGNOSTIC REPORT\")\n    print(\"=\" * 60)\n    \n    report = create_diagnostic_report()\n    print(f\"Timestamp: {report['timestamp']}\")\n    print(f\"Platform: {report['system']['platform']}\")\n    print(f\"Python: {report['system']['python_version'][:30]}...\")\n    \n    if report['disk_space']:\n        if 'free_gb' in report['disk_space']:\n            print(f\"Disk Space: {report['disk_space']['free_gb']}GB free\")\n    \n    print(\"\\n‚úÖ Error handling and recovery features are operational!\")\n    print(\"üéâ All critical components tested successfully!\")\n\nif __name__ == \"__main__\":\n    main()","size_bytes":11225},"create_sample_data.py":{"content":"import pandas as pd\nfrom pathlib import Path\n\n# Create sample data\ndata = {\n    'Email': [\n        'john.smith@example.com',\n        'sarah.johnson@company.com',\n        'michael.chen@business.org',\n        'emma.wilson@enterprise.net',\n        'david.brown@corporation.com'\n    ],\n    'FirstName': ['John', 'Sarah', 'Michael', 'Emma', 'David'],\n    'Company': ['TechCorp', 'DataSystems', 'CloudWorks', 'InnovateLab', 'DigitalHub'],\n    'Subject': [\n        'Investment Opportunity - TechCorp',\n        'Partnership Proposal - DataSystems',\n        'Strategic Alliance - CloudWorks',\n        'Business Opportunity - InnovateLab',\n        'Collaboration Request - DigitalHub'\n    ],\n    'CC': ['manager@example.com', '', 'team@business.org', '', 'supervisor@corporation.com'],\n    'SenderName': ['Brian', 'Brian', 'Brian', 'Brian', 'Brian'],\n    'MeetingDate': ['2025-01-15', '2025-01-17', '2025-01-20', '2025-01-22', '2025-01-25'],\n    'Discount': [10, 15, 20, 25, 30],\n    'SpecialOffer': [1, 0, 1, 0, 1],\n    'MeetingReminder': [0, 1, 1, 0, 1],\n    'BrochureInfo': [1, 1, 0, 1, 0]\n}\n\n# Create DataFrame\ndf = pd.DataFrame(data)\n\n# Save to Excel\noutput_path = Path('sample_recipients.xlsx')\ndf.to_excel(output_path, index=False)\n\nprint(f\"‚úÖ Sample Excel file created: {output_path}\")\nprint(f\"üìä Contains {len(df)} sample recipients\")\nprint(\"\\nColumns:\")\nfor col in df.columns:\n    print(f\"  - {col}\")\n\n# Also create a sample email template if needed\ntemplate_path = Path('sample_template.txt')\ntemplate_content = \"\"\"Dear [FirstName],\n\nI hope this message finds you well. I'm reaching out from our team regarding an exciting opportunity with [Company].\n\n[Conditional:SpecialOffer]\n\n[Conditional:MeetingReminder]\n\n[Conditional:BrochureInfo]\n\nWe believe this could be a valuable partnership for both our organizations.\n\nPlease let me know if you'd like to schedule a call to discuss this further.\n\nBest regards,\n[SenderName]\"\"\"\n\nwith open(template_path, 'w') as f:\n    f.write(template_content)\n\nprint(f\"\\n‚úÖ Sample template created: {template_path}\")","size_bytes":2052},"replit.md":{"content":"# Overview\n\nAn advanced email automation tool that generates personalized email files from templates and recipient data. The system uses Excel spreadsheets to store recipient information and supports both plain text and rich HTML templates with placeholder variables to create customized emails. It features a rich text editor with formatting options, conditional content insertion based on flags in the data, attachment handling, and outputs .eml files that can be opened in email clients or imported into Outlook.\n\n# User Preferences\n\nPreferred communication style: Simple, everyday language.\n\n# System Architecture\n\n## Frontend Architecture\n- **Streamlit Web Interface**: Multi-step workflow application with session state management\n- **Rich Text Editor**: Integrated Quill editor for HTML email creation with formatting toolbar\n- **Template Mode Toggle**: Switch between Plain Text and Rich Text editing modes\n- **Progressive Workflow**: Step-by-step process for template creation, data upload, variable mapping, and email generation\n- **Real-time Validation**: Immediate feedback on template variables and Excel column matching\n- **Live HTML Preview**: Real-time preview of formatted emails in rich text mode\n- **File Upload Handling**: Support for Excel files, text/HTML templates, and attachment directories\n\n## Backend Architecture\n- **Template Processing Engine**: Regex-based variable extraction and substitution system\n- **Conditional Content System**: JSON-driven conditional line insertion based on Excel flags\n- **Email Generation Module**: Creates .eml files with proper MIME formatting, HTML conversion, and attachment handling\n- **Data Validation Layer**: Ensures required columns exist and validates email addresses\n- **File Management**: Handles temporary files, output directories, and attachment processing\n\n## Data Processing\n- **Excel Data Handler**: Pandas-based spreadsheet processing with column validation\n- **Template Variable System**: Bracket-notation placeholders `[VariableName]` for dynamic content insertion\n- **Dual Template Format**: Support for both plain text and rich HTML templates\n- **Rich Text Editor**: Quill-based WYSIWYG editor with formatting toolbar (bold, italic, underline, font sizes, colors, lists, links)\n- **Format Preservation**: Maintains HTML formatting through template save/load cycle\n- **Conditional Logic**: Flag-based content inclusion using JSON configuration files\n- **Text Formatting**: Markdown-style formatting conversion to HTML (bold, italic, underline) for plain text mode\n\n## Email Generation\n- **MIME Message Creation**: Proper email structure with headers, body, and attachments\n- **Dual Format Support**: Handles both plain text templates with auto-HTML conversion and pre-formatted HTML templates\n- **HTML Email Support**: Direct HTML template usage in rich text mode, automatic conversion in plain text mode\n- **Format Detection**: Automatically determines template format and processes accordingly\n- **Multi-recipient Support**: Handles To, CC, and BCC fields with comma-separated addresses\n- **Attachment Processing**: Automatic file attachment based on Excel column references\n- **Outlook Compatibility**: Ensures HTML formatting is preserved when creating Outlook drafts\n\n# External Dependencies\n\n## Core Libraries\n- **Streamlit**: Web application framework for the user interface\n- **Streamlit-Quill**: Rich text editor component for HTML email creation\n- **Pandas**: Excel file processing and data manipulation\n- **Python Standard Library**: Email message creation (email.message), file operations (pathlib, os), regex processing, HTML handling\n\n## Optional Dependencies\n- **pywin32**: Windows COM integration for Outlook automation (optional, with graceful fallback)\n\n## File System Requirements\n- **Input Files**: Excel spreadsheets (.xlsx), text templates (.txt), conditional rules (JSON)\n- **Output Directory**: Generated .eml files stored in configurable output folder\n- **Attachments Directory**: Optional folder for files to be attached to emails\n\n## Data Format Dependencies\n- **Excel Structure**: Requires specific column names (Email/To, optional CC/BCC, From, Subject)\n- **Template Format**: Bracket notation for variables `[VariableName]` works in both plain and HTML templates\n- **HTML Templates**: Full HTML support with inline styles, links, lists, and formatting\n- **Template Storage**: JSON format stores template text, HTML version, format type, and metadata\n- **JSON Configuration**: Conditional content rules stored in JSON format","size_bytes":4532},"test_queue_system.py":{"content":"\"\"\"\nTest script to verify the email queue system is working correctly\n\"\"\"\n\nimport json\nfrom email_queue_manager import EmailQueueManager\nfrom datetime import datetime, timedelta\nimport pandas as pd\n\n\ndef test_queue_manager():\n    \"\"\"Test the queue manager functionality\"\"\"\n    print(\"Testing Email Queue Manager...\")\n    \n    # Initialize queue manager\n    queue_manager = EmailQueueManager()\n    \n    # Test 1: Add emails to queue\n    print(\"\\n1. Testing adding emails to queue...\")\n    test_emails = [\n        {\n            \"recipient\": \"alice@example.com\",\n            \"subject\": \"Test Email 1\",\n            \"body\": \"This is a test email for Alice.\"\n        },\n        {\n            \"recipient\": \"bob@example.com\",\n            \"subject\": \"Test Email 2\",\n            \"body\": \"This is a test email for Bob.\",\n            \"scheduled_time\": datetime.now() + timedelta(hours=1)\n        },\n        {\n            \"recipient\": \"charlie@example.com\",\n            \"subject\": \"Test Email 3\",\n            \"body\": \"This is a test email for Charlie.\",\n            \"scheduled_time\": datetime.now() + timedelta(days=1)\n        }\n    ]\n    \n    email_ids = []\n    for email in test_emails:\n        queue_id = queue_manager.add_to_queue(\n            recipient=email[\"recipient\"],\n            subject=email[\"subject\"],\n            body=email[\"body\"],\n            scheduled_time=email.get(\"scheduled_time\"),\n            priority=1,\n            tags=[\"test\"]\n        )\n        email_ids.append(queue_id)\n        print(f\"  Added email {queue_id[:8]}... to {email['recipient']}\")\n    \n    # Test 2: List emails\n    print(\"\\n2. Testing listing emails...\")\n    all_emails = queue_manager.list_emails()\n    print(f\"  Total emails in queue: {len(all_emails)}\")\n    \n    pending = queue_manager.list_emails(status=\"pending\")\n    scheduled = queue_manager.list_emails(status=\"scheduled\")\n    print(f\"  Pending: {len(pending)}, Scheduled: {len(scheduled)}\")\n    \n    # Test 3: Get statistics\n    print(\"\\n3. Testing statistics...\")\n    stats = queue_manager.get_statistics()\n    print(f\"  Statistics: {json.dumps(stats, indent=2)}\")\n    \n    # Test 4: Get due emails\n    print(\"\\n4. Testing due emails...\")\n    due_emails = queue_manager.get_due_emails()\n    print(f\"  Emails due now: {len(due_emails)}\")\n    \n    # Test 5: Update email status\n    print(\"\\n5. Testing status update...\")\n    if email_ids:\n        success = queue_manager.update_email(email_ids[0], {\"status\": \"draft_created\"})\n        print(f\"  Updated email {email_ids[0][:8]}...: {success}\")\n    \n    # Test 6: Batch scheduling\n    print(\"\\n6. Testing batch scheduling...\")\n    if len(email_ids) > 1:\n        start_time = datetime.now() + timedelta(hours=2)\n        success = queue_manager.schedule_batch(\n            email_ids[1:],\n            start_time,\n            interval_minutes=30,\n            emails_per_batch=1\n        )\n        print(f\"  Batch scheduled: {success}\")\n    \n    # Test 7: Export queue\n    print(\"\\n7. Testing export...\")\n    export_file = \"test_queue_export.csv\"\n    success = queue_manager.export_queue(export_file)\n    if success:\n        print(f\"  Queue exported to {export_file}\")\n        df = pd.read_csv(export_file)\n        print(f\"  Exported {len(df)} rows\")\n    \n    print(\"\\n‚úÖ All tests completed successfully!\")\n    return True\n\n\ndef test_integration():\n    \"\"\"Test the integration with the Streamlit app\"\"\"\n    print(\"\\n\\nTesting Integration with Streamlit App...\")\n    \n    # Check if all required files exist\n    from pathlib import Path\n    \n    required_files = [\n        \"app.py\",\n        \"email_queue_manager.py\",\n        \"step_7_queue_management.py\",\n        \"email_file_generator.py\",\n        \"template_manager.py\"\n    ]\n    \n    missing_files = []\n    for file in required_files:\n        if not Path(file).exists():\n            missing_files.append(file)\n    \n    if missing_files:\n        print(f\"‚ùå Missing files: {missing_files}\")\n        return False\n    \n    print(\"‚úÖ All required files present\")\n    \n    # Check if Step 7 is properly integrated\n    with open(\"app.py\", 'r') as f:\n        app_content = f.read()\n    \n    checks = [\n        (\"Step 7 in navigation\", '\"7. Queue & Scheduling\"' in app_content),\n        (\"Queue manager import\", 'from email_queue_manager import EmailQueueManager' in app_content),\n        (\"Step 7 function import\", 'from step_7_queue_management import step_7_queue_management' in app_content),\n        (\"Step 7 routing\", 'st.session_state.current_step == 7' in app_content),\n        (\"Add to Queue section\", '\"Add to Email Queue\"' in app_content or 'Add to Email Queue' in app_content)\n    ]\n    \n    all_passed = True\n    for check_name, check_result in checks:\n        status = \"‚úÖ\" if check_result else \"‚ùå\"\n        print(f\"  {status} {check_name}\")\n        if not check_result:\n            all_passed = False\n    \n    if all_passed:\n        print(\"\\n‚úÖ Integration tests passed!\")\n    else:\n        print(\"\\n‚ö†Ô∏è Some integration checks failed\")\n    \n    return all_passed\n\n\nif __name__ == \"__main__\":\n    print(\"=\"*50)\n    print(\"EMAIL QUEUE SYSTEM TEST\")\n    print(\"=\"*50)\n    \n    # Run tests\n    queue_test_passed = test_queue_manager()\n    integration_test_passed = test_integration()\n    \n    print(\"\\n\" + \"=\"*50)\n    print(\"TEST SUMMARY\")\n    print(\"=\"*50)\n    print(f\"Queue Manager Tests: {'‚úÖ PASSED' if queue_test_passed else '‚ùå FAILED'}\")\n    print(f\"Integration Tests: {'‚úÖ PASSED' if integration_test_passed else '‚ùå FAILED'}\")\n    \n    if queue_test_passed and integration_test_passed:\n        print(\"\\nüéâ All tests passed! The email queue system is ready to use.\")\n    else:\n        print(\"\\n‚ö†Ô∏è Some tests failed. Please review the implementation.\")","size_bytes":5712},"pyproject.toml":{"content":"[project]\nname = \"repl-nix-workspace\"\nversion = \"0.1.0\"\ndescription = \"Add your description here\"\nrequires-python = \">=3.11\"\ndependencies = [\n    \"openpyxl>=3.1.5\",\n    \"pandas>=2.3.2\",\n    \"streamlit-quill>=0.0.3\",\n    \"streamlit>=1.49.1\",\n]\n","size_bytes":243},"test_attachment_modes.py":{"content":"#!/usr/bin/env python3\n\"\"\"Test script to verify both Global and Per-Recipient attachment modes work correctly.\"\"\"\n\nimport os\nimport pandas as pd\nimport json\nfrom pathlib import Path\nimport shutil\nimport email_file_generator as efg\n\ndef setup_test_data():\n    \"\"\"Setup test data for testing attachment modes.\"\"\"\n    \n    # Create test directories\n    test_dir = Path(\"test_attachment_run\")\n    test_dir.mkdir(exist_ok=True)\n    \n    # Create global attachments directory\n    global_attachments = test_dir / \"global_attachments\"\n    global_attachments.mkdir(exist_ok=True)\n    \n    # Create sample global attachment files\n    (global_attachments / \"global_doc.txt\").write_text(\"This is a global document\")\n    (global_attachments / \"global_report.pdf\").write_bytes(b\"PDF content placeholder\")\n    \n    # Create per-recipient attachments directories\n    per_recipient_base = test_dir / \"per_recipient_attachments\"\n    per_recipient_base.mkdir(exist_ok=True)\n    \n    # Create folders for specific recipients\n    alice_folder = per_recipient_base / \"Alice\"\n    alice_folder.mkdir(exist_ok=True)\n    (alice_folder / \"alice_invoice.txt\").write_text(\"Invoice for Alice\")\n    (alice_folder / \"alice_contract.pdf\").write_bytes(b\"Alice contract PDF\")\n    \n    bob_folder = per_recipient_base / \"Bob\"\n    bob_folder.mkdir(exist_ok=True)\n    (bob_folder / \"bob_proposal.txt\").write_text(\"Proposal for Bob\")\n    \n    # Create test Excel data\n    test_data = pd.DataFrame({\n        'FirstName': ['Alice', 'Bob', 'Charlie'],\n        'LastName': ['Smith', 'Jones', 'Brown'],\n        'Email': ['alice@example.com', 'bob@example.com', 'charlie@example.com'],\n        'Company': ['Tech Corp', 'Sales Inc', 'Marketing Ltd'],\n        'Subject': ['Meeting Request', 'Project Update', 'Partnership Proposal']\n    })\n    \n    excel_path = test_dir / \"test_recipients.xlsx\"\n    test_data.to_excel(excel_path, index=False)\n    \n    # Create test template\n    template_text = \"\"\"Dear [FirstName] [LastName],\n\nI hope this email finds you well.\n\nI'm reaching out to you from [Company] regarding the subject: [Subject].\n\nThis is a test email to verify attachment functionality.\n\nBest regards,\nTest Sender\"\"\"\n    \n    template_path = test_dir / \"test_template.txt\"\n    template_path.write_text(template_text)\n    \n    # Create empty conditional lines file\n    conditionals_path = test_dir / \"conditional_lines.json\"\n    with open(conditionals_path, 'w') as f:\n        json.dump({}, f)\n    \n    return {\n        'test_dir': test_dir,\n        'template_path': template_path,\n        'excel_path': excel_path,\n        'global_attachments': global_attachments,\n        'per_recipient_base': per_recipient_base,\n        'conditionals_path': conditionals_path\n    }\n\ndef test_global_attachments(paths):\n    \"\"\"Test global attachment mode.\"\"\"\n    print(\"\\n=== Testing Global Attachment Mode ===\")\n    \n    output_dir = paths['test_dir'] / \"output_global\"\n    output_dir.mkdir(exist_ok=True)\n    \n    result = efg.main(\n        template_path=str(paths['template_path']),\n        excel_path=str(paths['excel_path']),\n        attachments_dir=str(paths['global_attachments']),\n        output_dir=str(output_dir),\n        conditionals_path=str(paths['conditionals_path']),\n        use_outlook=False,  # Don't create Outlook drafts for testing\n        create_eml_backup=True,\n        is_html_template=False,\n        attachment_mode=\"global\",\n        per_recipient_base=None,\n        identifier_column=None\n    )\n    \n    print(\"\\nGlobal Mode Test Results:\")\n    if isinstance(result, dict):\n        print(f\"  Success: {result['success']}\")\n        print(f\"  Successful emails: {result['success_count']}\")\n        print(f\"  Failed emails: {result['error_count']}\")\n        print(f\"  Total processed: {result['total_count']}\")\n        \n        # Check that .eml files were created\n        eml_files = list(output_dir.glob(\"*.eml\"))\n        print(f\"  .eml files created: {len(eml_files)}\")\n        \n        # Verify each .eml file has attachments\n        for eml_file in eml_files[:1]:  # Check first file\n            print(f\"\\n  Checking {eml_file.name}:\")\n            with open(eml_file, 'r', encoding='utf-8') as f:\n                content = f.read()\n                if \"global_doc.txt\" in content:\n                    print(\"    ‚úì Found global_doc.txt attachment\")\n                if \"global_report.pdf\" in content:\n                    print(\"    ‚úì Found global_report.pdf attachment\")\n    else:\n        print(f\"  Legacy format result: {result}\")\n    \n    return result\n\ndef test_per_recipient_attachments(paths):\n    \"\"\"Test per-recipient attachment mode.\"\"\"\n    print(\"\\n=== Testing Per-Recipient Attachment Mode ===\")\n    \n    output_dir = paths['test_dir'] / \"output_per_recipient\"\n    output_dir.mkdir(exist_ok=True)\n    \n    result = efg.main(\n        template_path=str(paths['template_path']),\n        excel_path=str(paths['excel_path']),\n        attachments_dir=str(paths['global_attachments']),  # Fallback for recipients without folders\n        output_dir=str(output_dir),\n        conditionals_path=str(paths['conditionals_path']),\n        use_outlook=False,  # Don't create Outlook drafts for testing\n        create_eml_backup=True,\n        is_html_template=False,\n        attachment_mode=\"per_recipient\",\n        per_recipient_base=str(paths['per_recipient_base']),\n        identifier_column=\"FirstName\"\n    )\n    \n    print(\"\\nPer-Recipient Mode Test Results:\")\n    if isinstance(result, dict):\n        print(f\"  Success: {result['success']}\")\n        print(f\"  Successful emails: {result['success_count']}\")\n        print(f\"  Failed emails: {result['error_count']}\")\n        print(f\"  Total processed: {result['total_count']}\")\n        \n        # Check that .eml files were created\n        eml_files = list(output_dir.glob(\"*.eml\"))\n        print(f\"  .eml files created: {len(eml_files)}\")\n        \n        # Verify Alice's email has her specific attachments\n        alice_file = None\n        for eml_file in eml_files:\n            if \"Alice\" in eml_file.name:\n                alice_file = eml_file\n                break\n        \n        if alice_file:\n            print(f\"\\n  Checking Alice's email ({alice_file.name}):\")\n            with open(alice_file, 'r', encoding='utf-8') as f:\n                content = f.read()\n                if \"alice_invoice.txt\" in content:\n                    print(\"    ‚úì Found alice_invoice.txt attachment\")\n                if \"alice_contract.pdf\" in content:\n                    print(\"    ‚úì Found alice_contract.pdf attachment\")\n        \n        # Verify Bob's email has his specific attachments\n        bob_file = None\n        for eml_file in eml_files:\n            if \"Bob\" in eml_file.name:\n                bob_file = eml_file\n                break\n        \n        if bob_file:\n            print(f\"\\n  Checking Bob's email ({bob_file.name}):\")\n            with open(bob_file, 'r', encoding='utf-8') as f:\n                content = f.read()\n                if \"bob_proposal.txt\" in content:\n                    print(\"    ‚úì Found bob_proposal.txt attachment\")\n        \n        # Verify Charlie's email (should use global attachments as fallback)\n        charlie_file = None\n        for eml_file in eml_files:\n            if \"Charlie\" in eml_file.name:\n                charlie_file = eml_file\n                break\n        \n        if charlie_file:\n            print(f\"\\n  Checking Charlie's email ({charlie_file.name}) - should have global attachments as fallback:\")\n            with open(charlie_file, 'r', encoding='utf-8') as f:\n                content = f.read()\n                if \"global_doc.txt\" in content or \"global_report.pdf\" in content:\n                    print(\"    ‚úì Found global attachments (fallback worked)\")\n                else:\n                    print(\"    ‚ö† No attachments found (Charlie has no per-recipient folder)\")\n    else:\n        print(f\"  Legacy format result: {result}\")\n    \n    return result\n\ndef cleanup_test_data(test_dir):\n    \"\"\"Clean up test data after testing.\"\"\"\n    if test_dir.exists():\n        shutil.rmtree(test_dir)\n        print(f\"\\n‚úì Cleaned up test directory: {test_dir}\")\n\ndef main():\n    \"\"\"Run all attachment mode tests.\"\"\"\n    print(\"=\" * 60)\n    print(\"Testing Email Generator Attachment Modes\")\n    print(\"=\" * 60)\n    \n    try:\n        # Setup test data\n        paths = setup_test_data()\n        print(f\"\\n‚úì Test data created in: {paths['test_dir']}\")\n        \n        # Test global attachment mode\n        global_result = test_global_attachments(paths)\n        \n        # Test per-recipient attachment mode\n        per_recipient_result = test_per_recipient_attachments(paths)\n        \n        # Summary\n        print(\"\\n\" + \"=\" * 60)\n        print(\"Test Summary\")\n        print(\"=\" * 60)\n        \n        global_success = isinstance(global_result, dict) and global_result['success'] or global_result == True\n        per_recipient_success = isinstance(per_recipient_result, dict) and per_recipient_result['success'] or per_recipient_result == True\n        \n        if global_success:\n            print(\"‚úÖ Global attachment mode: PASSED\")\n        else:\n            print(\"‚ùå Global attachment mode: FAILED\")\n        \n        if per_recipient_success:\n            print(\"‚úÖ Per-recipient attachment mode: PASSED\")\n        else:\n            print(\"‚ùå Per-recipient attachment mode: FAILED\")\n        \n        # Clean up\n        cleanup_test_data(paths['test_dir'])\n        \n        if global_success and per_recipient_success:\n            print(\"\\nüéâ All tests passed successfully!\")\n            return 0\n        else:\n            print(\"\\n‚ö†Ô∏è Some tests failed. Please review the output above.\")\n            return 1\n            \n    except Exception as e:\n        print(f\"\\n‚ùå Test failed with error: {e}\")\n        import traceback\n        traceback.print_exc()\n        return 1\n\nif __name__ == \"__main__\":\n    exit(main())","size_bytes":9917},"test_rich_text_features.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nTest script to verify rich text editor features in the Email Generator\nTests HTML template handling, variable replacement, and formatting preservation\n\"\"\"\n\nimport sys\nimport os\nimport json\nimport pandas as pd\nfrom pathlib import Path\nimport tempfile\n\n# Add parent directory to path for imports\nsys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))\n\nimport email_file_generator as efg\nfrom template_manager import TemplateManager\n\ndef test_html_template_creation():\n    \"\"\"Test creating and processing HTML templates with rich formatting\"\"\"\n    print(\"\\n=== Testing HTML Template Creation ===\")\n    \n    # Create a rich HTML template with formatting\n    html_template = \"\"\"\n    <h2>Welcome [FirstName]!</h2>\n    <p>We're excited to have you join <b>[Company]</b> as our new <i>[Position]</i>.</p>\n    \n    <p style=\"color: blue;\">Here are your <u>onboarding details</u>:</p>\n    <ul>\n        <li>Start Date: <strong>[StartDate]</strong></li>\n        <li>Department: <span style=\"color: green;\">[Department]</span></li>\n        <li>Manager: [Manager]</li>\n    </ul>\n    \n    <p>Please visit our <a href=\"https://example.com\">company portal</a> to complete your paperwork.</p>\n    \n    [Conditional:Premium]\n    \n    <p style=\"font-size: 18px;\">We look forward to working with you!</p>\n    <br>\n    <p><em>Best regards,<br>\n    The [Company] Team</em></p>\n    \"\"\"\n    \n    # Create test data\n    test_data = pd.DataFrame({\n        'FirstName': ['Alice', 'Bob', 'Charlie'],\n        'Company': ['TechCorp', 'DataInc', 'WebSoft'],\n        'Position': ['Developer', 'Analyst', 'Designer'],\n        'StartDate': ['Jan 15', 'Jan 20', 'Feb 1'],\n        'Department': ['Engineering', 'Analytics', 'Design'],\n        'Manager': ['John Smith', 'Jane Doe', 'Mike Wilson'],\n        'Email': ['alice@test.com', 'bob@test.com', 'charlie@test.com'],\n        'Subject': ['Welcome to TechCorp', 'Welcome to DataInc', 'Welcome to WebSoft'],\n        'Premium': [1, 0, 1]\n    })\n    \n    # Save template and data to temp files\n    with tempfile.NamedTemporaryFile(mode='w', suffix='.html', delete=False) as f:\n        f.write(html_template)\n        template_path = f.name\n    \n    with tempfile.NamedTemporaryFile(suffix='.xlsx', delete=False) as f:\n        test_data.to_excel(f.name, index=False)\n        excel_path = f.name\n    \n    # Create conditional lines\n    conditional_lines = {\n        'Premium': '<p style=\"background-color: gold; padding: 10px;\"><b>Premium Package:</b> As a premium member, you get access to exclusive benefits including gym membership and enhanced healthcare!</p>'\n    }\n    \n    conditionals_path = 'test_conditionals.json'\n    with open(conditionals_path, 'w') as f:\n        json.dump(conditional_lines, f)\n    \n    # Test with output directory\n    output_dir = Path('test_rich_text_output')\n    output_dir.mkdir(exist_ok=True)\n    \n    try:\n        # Extract variables\n        variables = efg.extract_variables(html_template)\n        print(f\"‚úÖ Extracted variables: {variables}\")\n        \n        # Process first row for testing\n        row = test_data.iloc[0]\n        \n        # Test HTML template processing\n        msg = efg.create_email_message(\n            row=row,\n            template_text=html_template,\n            variables=variables,\n            attachments_dir=None,\n            attachment_columns=[],\n            conditional_lines=conditional_lines,\n            is_html_template=True\n        )\n        \n        # Save the email\n        email_file = output_dir / f\"test_email_{row['FirstName']}.eml\"\n        with open(email_file, 'w', encoding='utf-8') as f:\n            f.write(str(msg))\n        \n        print(f\"‚úÖ Created HTML email: {email_file}\")\n        \n        # Verify the email contains HTML content\n        email_content = str(msg)\n        assert '<h2>Welcome Alice!</h2>' in email_content\n        assert '<b>TechCorp</b>' in email_content\n        assert 'Premium Package' in email_content  # Conditional content\n        print(\"‚úÖ HTML formatting preserved in email\")\n        \n        # Test plain text template for comparison\n        plain_template = \"\"\"\nWelcome [FirstName]!\n\nWe're excited to have you join [Company] as our new [Position].\n\nHere are your onboarding details:\n- Start Date: [StartDate]\n- Department: [Department]\n- Manager: [Manager]\n\n[Conditional:Premium]\n\nWe look forward to working with you!\n\nBest regards,\nThe [Company] Team\n        \"\"\"\n        \n        msg_plain = efg.create_email_message(\n            row=row,\n            template_text=plain_template,\n            variables=variables,\n            attachments_dir=None,\n            attachment_columns=[],\n            conditional_lines={'Premium': 'Premium Package: You get exclusive benefits!'},\n            is_html_template=False\n        )\n        \n        email_file_plain = output_dir / f\"test_email_{row['FirstName']}_plain.eml\"\n        with open(email_file_plain, 'w', encoding='utf-8') as f:\n            f.write(str(msg_plain))\n        \n        print(f\"‚úÖ Created plain text email: {email_file_plain}\")\n        \n        return True\n        \n    except Exception as e:\n        print(f\"‚ùå Error in HTML template test: {e}\")\n        return False\n    finally:\n        # Cleanup temp files\n        if os.path.exists(template_path):\n            os.remove(template_path)\n        if os.path.exists(excel_path):\n            os.remove(excel_path)\n        if os.path.exists(conditionals_path):\n            os.remove(conditionals_path)\n\ndef test_template_manager_with_html():\n    \"\"\"Test saving and loading HTML templates with the TemplateManager\"\"\"\n    print(\"\\n=== Testing Template Manager with HTML ===\")\n    \n    tm = TemplateManager(\"test_templates\")\n    \n    # Create test HTML template\n    html_content = \"\"\"\n    <div style=\"font-family: Arial, sans-serif;\">\n        <h1 style=\"color: navy;\">Hello [Name]!</h1>\n        <p>This is a <b>rich text</b> template with <i>formatting</i>.</p>\n        <ul>\n            <li>Item 1: [Item1]</li>\n            <li>Item 2: [Item2]</li>\n        </ul>\n    </div>\n    \"\"\"\n    \n    plain_content = \"Hello [Name]!\\nThis is a rich text template with formatting.\\n- Item 1: [Item1]\\n- Item 2: [Item2]\"\n    \n    try:\n        # Save HTML template\n        result = tm.save_template(\n            name=\"Test Rich Template\",\n            template_text=plain_content,\n            description=\"A test template with HTML formatting\",\n            format_type=\"rich\",\n            template_html=html_content\n        )\n        \n        assert result['success'], f\"Failed to save template: {result.get('message')}\"\n        print(\"‚úÖ Saved HTML template successfully\")\n        \n        # List templates\n        templates = tm.list_templates()\n        rich_templates = [t for t in templates if t.get('format_type') == 'rich']\n        assert len(rich_templates) > 0, \"No rich text templates found\"\n        print(f\"‚úÖ Found {len(rich_templates)} rich text template(s)\")\n        \n        # Load the template back\n        test_template = rich_templates[0]\n        result = tm.load_template(test_template['filename'])\n        assert result['success'], f\"Failed to load template: {result.get('message')}\"\n        \n        data = result['data']\n        assert data['format_type'] == 'rich', \"Format type not preserved\"\n        assert 'template_html' in data, \"HTML content not saved\"\n        assert '<h1' in data['template_html'], \"HTML tags not preserved\"\n        print(\"‚úÖ Loaded HTML template with formatting preserved\")\n        \n        # Clean up\n        tm.delete_template(test_template['filename'])\n        print(\"‚úÖ Cleaned up test template\")\n        \n        return True\n        \n    except Exception as e:\n        print(f\"‚ùå Error in template manager test: {e}\")\n        return False\n\ndef test_variable_preservation_in_html():\n    \"\"\"Test that variable placeholders work correctly in HTML content\"\"\"\n    print(\"\\n=== Testing Variable Preservation in HTML ===\")\n    \n    html_with_vars = \"\"\"\n    <p>Dear <strong>[CustomerName]</strong>,</p>\n    <p>Your order #<span style=\"color: red;\">[OrderNumber]</span> has been shipped!</p>\n    <p>Tracking: <a href=\"[TrackingURL]\">[TrackingNumber]</a></p>\n    \"\"\"\n    \n    test_row = pd.Series({\n        'CustomerName': 'John Doe',\n        'OrderNumber': '12345',\n        'TrackingURL': 'https://track.example.com/12345',\n        'TrackingNumber': 'TRK-12345',\n        'Email': 'john@example.com',\n        'Subject': 'Order Shipped'\n    })\n    \n    variables = efg.extract_variables(html_with_vars)\n    print(f\"Variables found: {variables}\")\n    \n    # Fill template\n    filled = efg.fill_template(html_with_vars, test_row, variables)\n    \n    # Verify replacements\n    assert 'John Doe' in filled\n    assert '12345' in filled\n    assert 'TRK-12345' in filled\n    assert '[CustomerName]' not in filled\n    \n    print(\"‚úÖ All variables correctly replaced in HTML template\")\n    return True\n\ndef main():\n    \"\"\"Run all tests\"\"\"\n    print(\"\\n\" + \"=\"*50)\n    print(\"RICH TEXT EDITOR FEATURE TESTS\")\n    print(\"=\"*50)\n    \n    tests_passed = 0\n    tests_total = 3\n    \n    # Run tests\n    if test_html_template_creation():\n        tests_passed += 1\n    \n    if test_template_manager_with_html():\n        tests_passed += 1\n    \n    if test_variable_preservation_in_html():\n        tests_passed += 1\n    \n    # Summary\n    print(\"\\n\" + \"=\"*50)\n    print(f\"TEST SUMMARY: {tests_passed}/{tests_total} tests passed\")\n    \n    if tests_passed == tests_total:\n        print(\"‚úÖ ALL TESTS PASSED - Rich text features working correctly!\")\n    else:\n        print(f\"‚ö†Ô∏è {tests_total - tests_passed} test(s) failed\")\n    \n    print(\"=\"*50)\n    \n    return tests_passed == tests_total\n\nif __name__ == \"__main__\":\n    success = main()\n    sys.exit(0 if success else 1)","size_bytes":9762},"template_manager.py":{"content":"\"\"\"\nTemplate Manager Module\nHandles saving, loading, deleting, and listing email templates\n\"\"\"\n\nimport json\nimport os\nfrom pathlib import Path\nfrom datetime import datetime\nfrom typing import Dict, List, Optional, Any\nimport re\n\nclass TemplateManager:\n    def __init__(self, templates_dir: str = \"templates\"):\n        \"\"\"Initialize the template manager with a templates directory.\"\"\"\n        self.templates_dir = Path(templates_dir)\n        self.templates_dir.mkdir(exist_ok=True)\n    \n    def extract_variables(self, template_text: str) -> List[str]:\n        \"\"\"Extract all variable placeholders from template text.\"\"\"\n        # Extract regular variables [VarName]\n        all_vars = re.findall(r\"\\[([^\\]]+)\\]\", template_text)\n        # Filter out conditional placeholders\n        regular_vars = [var for var in all_vars if not var.startswith(\"Conditional:\")]\n        return regular_vars\n    \n    def extract_conditional_keys(self, template_text: str) -> List[str]:\n        \"\"\"Extract conditional placeholder keys from template text.\"\"\"\n        conditionals = re.findall(r\"\\[Conditional:([^\\]]+)\\]\", template_text)\n        return conditionals\n    \n    def save_template(self, name: str, template_text: str, description: str = \"\", format_type: str = \"plain\", template_html: Optional[str] = None) -> Dict[str, Any]:\n        \"\"\"\n        Save a template to a JSON file.\n        \n        Args:\n            name: Template name\n            template_text: The template content\n            description: Optional description of the template\n            \n        Returns:\n            Dict with success status and message\n        \"\"\"\n        try:\n            # Create filename from name (sanitize for filesystem)\n            filename = \"\".join(c if c.isalnum() or c in (' ', '-', '_') else '_' for c in name)\n            filename = filename.lower().replace(' ', '_') + '.json'\n            filepath = self.templates_dir / filename\n            \n            # Check if template already exists\n            is_overwrite = filepath.exists()\n            \n            # Extract variables and conditional keys\n            variables = self.extract_variables(template_text)\n            conditional_keys = self.extract_conditional_keys(template_text)\n            \n            # Create template data\n            template_data = {\n                \"name\": name,\n                \"description\": description,\n                \"created_date\": datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\"),\n                \"template_text\": template_text,\n                \"variables\": variables,\n                \"conditional_keys\": conditional_keys,\n                \"format_type\": format_type,\n                \"template_html\": template_html  # Store HTML version if available\n            }\n            \n            # If updating existing template, preserve original creation date\n            if is_overwrite:\n                try:\n                    with open(filepath, 'r', encoding='utf-8') as f:\n                        existing_data = json.load(f)\n                        template_data[\"created_date\"] = existing_data.get(\"created_date\", template_data[\"created_date\"])\n                        template_data[\"modified_date\"] = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n                except:\n                    pass  # If we can't read the existing file, just use new creation date\n            \n            # Save to file\n            with open(filepath, 'w', encoding='utf-8') as f:\n                json.dump(template_data, f, indent=2, ensure_ascii=False)\n            \n            # Return appropriate message\n            if is_overwrite:\n                return {\n                    \"success\": True,\n                    \"message\": f\"Template '{name}' updated successfully (overwrote existing template)\",\n                    \"filepath\": str(filepath),\n                    \"overwrite\": True\n                }\n            else:\n                return {\n                    \"success\": True,\n                    \"message\": f\"Template '{name}' saved successfully\",\n                    \"filepath\": str(filepath),\n                    \"overwrite\": False\n                }\n            \n        except Exception as e:\n            return {\n                \"success\": False,\n                \"message\": f\"Error saving template: {str(e)}\"\n            }\n    \n    def load_template(self, filename: str) -> Dict[str, Any]:\n        \"\"\"\n        Load a template from a JSON file.\n        \n        Args:\n            filename: The template filename\n            \n        Returns:\n            Dict with template data or error info\n        \"\"\"\n        try:\n            filepath = self.templates_dir / filename\n            \n            if not filepath.exists():\n                return {\n                    \"success\": False,\n                    \"message\": f\"Template file not found: {filename}\"\n                }\n            \n            with open(filepath, 'r', encoding='utf-8') as f:\n                template_data = json.load(f)\n            \n            return {\n                \"success\": True,\n                \"data\": template_data\n            }\n            \n        except json.JSONDecodeError:\n            return {\n                \"success\": False,\n                \"message\": f\"Error reading template: Invalid JSON format\"\n            }\n        except Exception as e:\n            return {\n                \"success\": False,\n                \"message\": f\"Error loading template: {str(e)}\"\n            }\n    \n    def delete_template(self, filename: str) -> Dict[str, Any]:\n        \"\"\"\n        Delete a template file.\n        \n        Args:\n            filename: The template filename to delete\n            \n        Returns:\n            Dict with success status and message\n        \"\"\"\n        try:\n            filepath = self.templates_dir / filename\n            \n            if not filepath.exists():\n                return {\n                    \"success\": False,\n                    \"message\": f\"Template file not found: {filename}\"\n                }\n            \n            # Load template to get its name for the message\n            with open(filepath, 'r', encoding='utf-8') as f:\n                template_data = json.load(f)\n                template_name = template_data.get('name', filename)\n            \n            # Delete the file\n            filepath.unlink()\n            \n            return {\n                \"success\": True,\n                \"message\": f\"Template '{template_name}' deleted successfully\"\n            }\n            \n        except Exception as e:\n            return {\n                \"success\": False,\n                \"message\": f\"Error deleting template: {str(e)}\"\n            }\n    \n    def list_templates(self) -> List[Dict[str, Any]]:\n        \"\"\"\n        List all available templates.\n        \n        Returns:\n            List of template metadata dictionaries\n        \"\"\"\n        templates = []\n        \n        try:\n            # Get all JSON files in templates directory\n            for filepath in sorted(self.templates_dir.glob(\"*.json\")):\n                try:\n                    with open(filepath, 'r', encoding='utf-8') as f:\n                        template_data = json.load(f)\n                    \n                    # Add filename to the data\n                    template_data['filename'] = filepath.name\n                    \n                    # Create summary info\n                    template_info = {\n                        'filename': filepath.name,\n                        'name': template_data.get('name', filepath.stem),\n                        'description': template_data.get('description', ''),\n                        'created_date': template_data.get('created_date', ''),\n                        'variable_count': len(template_data.get('variables', [])),\n                        'has_conditionals': len(template_data.get('conditional_keys', [])) > 0,\n                        'format_type': template_data.get('format_type', 'plain')  # Default to plain for older templates\n                    }\n                    \n                    templates.append(template_info)\n                    \n                except (json.JSONDecodeError, KeyError):\n                    # Skip invalid template files\n                    continue\n                    \n        except Exception as e:\n            print(f\"Error listing templates: {str(e)}\")\n        \n        return templates\n    \n    def get_template_details(self, filename: str) -> Optional[Dict[str, Any]]:\n        \"\"\"\n        Get detailed information about a specific template.\n        \n        Args:\n            filename: The template filename\n            \n        Returns:\n            Template data dictionary or None if not found\n        \"\"\"\n        result = self.load_template(filename)\n        if result['success']:\n            return result['data']\n        return None\n    \n    def export_template(self, filename: str, export_path: str) -> Dict[str, Any]:\n        \"\"\"\n        Export a template to a different location.\n        \n        Args:\n            filename: The template filename\n            export_path: Path where to export the template\n            \n        Returns:\n            Dict with success status and message\n        \"\"\"\n        try:\n            source = self.templates_dir / filename\n            destination = Path(export_path)\n            \n            if not source.exists():\n                return {\n                    \"success\": False,\n                    \"message\": f\"Template file not found: {filename}\"\n                }\n            \n            # Copy the file\n            with open(source, 'r', encoding='utf-8') as f:\n                content = f.read()\n            \n            with open(destination, 'w', encoding='utf-8') as f:\n                f.write(content)\n            \n            return {\n                \"success\": True,\n                \"message\": f\"Template exported to {destination}\"\n            }\n            \n        except Exception as e:\n            return {\n                \"success\": False,\n                \"message\": f\"Error exporting template: {str(e)}\"\n            }\n    \n    def update_template(self, filename: str, template_text: str, description: Optional[str] = None, format_type: Optional[str] = None, template_html: Optional[str] = None) -> Dict[str, Any]:\n        \"\"\"\n        Update an existing template.\n        \n        Args:\n            filename: The template filename to update\n            template_text: New template content\n            description: Optional new description\n            \n        Returns:\n            Dict with success status and message\n        \"\"\"\n        try:\n            filepath = self.templates_dir / filename\n            \n            if not filepath.exists():\n                return {\n                    \"success\": False,\n                    \"message\": f\"Template file not found: {filename}\"\n                }\n            \n            # Load existing template\n            with open(filepath, 'r', encoding='utf-8') as f:\n                template_data = json.load(f)\n            \n            # Update fields\n            template_data['template_text'] = template_text\n            template_data['variables'] = self.extract_variables(template_text)\n            template_data['conditional_keys'] = self.extract_conditional_keys(template_text)\n            template_data['modified_date'] = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n            \n            if description is not None:\n                template_data['description'] = description\n            \n            if format_type is not None:\n                template_data['format_type'] = format_type\n            \n            if template_html is not None:\n                template_data['template_html'] = template_html\n            \n            # Save updated template\n            with open(filepath, 'w', encoding='utf-8') as f:\n                json.dump(template_data, f, indent=2, ensure_ascii=False)\n            \n            return {\n                \"success\": True,\n                \"message\": f\"Template '{template_data['name']}' updated successfully\"\n            }\n            \n        except Exception as e:\n            return {\n                \"success\": False,\n                \"message\": f\"Error updating template: {str(e)}\"\n            }","size_bytes":12227},"test_final_verification.py":{"content":"#!/usr/bin/env python3\n\"\"\"Final verification test for template library fixes\"\"\"\n\nimport json\nimport os\nfrom pathlib import Path\nfrom template_manager import TemplateManager\nimport re\n\ndef test_all_fixes():\n    \"\"\"Comprehensive test to verify all requested fixes\"\"\"\n    print(\"=== FINAL VERIFICATION OF TEMPLATE LIBRARY FIXES ===\\n\")\n    \n    # Initialize template manager\n    tm = TemplateManager(\"templates\")\n    \n    # FIX 1: Verify export_template method works correctly\n    print(\"1. TESTING EXPORT_TEMPLATE METHOD\")\n    print(\"-\" * 40)\n    \n    # Create a test template first\n    test_template = \"\"\"Dear [FirstName] [LastName],\n\nWelcome to [Company]! Your account [AccountID] has been created.\n\n[Conditional:Premium]\n\nBest regards,\n[TeamName]\"\"\"\n    \n    # Save the template\n    save_result = tm.save_template(\n        name=\"Export Test Template\",\n        template_text=test_template,\n        description=\"Testing export functionality\"\n    )\n    print(f\"   Created template: {save_result['message']}\")\n    \n    # Export the template\n    export_path = Path(\"exported_test_template.json\")\n    export_result = tm.export_template(\"export_test_template.json\", str(export_path))\n    print(f\"   Export result: {export_result['message']}\")\n    print(f\"   ‚úÖ Export successful: {export_result['success']}\")\n    \n    # Verify exported file exists and contains correct data\n    if export_path.exists():\n        with open(export_path, 'r') as f:\n            exported_data = json.load(f)\n        print(f\"   ‚úÖ Exported file exists with template: '{exported_data['name']}'\")\n        export_path.unlink()  # Clean up\n    else:\n        print(\"   ‚ùå Export failed - file not created\")\n    \n    print()\n    \n    # FIX 2: Verify template variable recomputation\n    print(\"2. TESTING VARIABLE RECOMPUTATION ON LOAD\")\n    print(\"-\" * 40)\n    \n    # The extract_variables function from app.py (simulated here)\n    def extract_variables_fixed(template_text: str):\n        \"\"\"Extract variables from template text (excluding conditional placeholders)\"\"\"\n        all_vars = re.findall(r\"\\[([^\\]]+)\\]\", template_text)\n        regular_vars = [var for var in all_vars if not var.startswith(\"Conditional:\")]\n        return regular_vars\n    \n    # Load the template\n    load_result = tm.load_template(\"export_test_template.json\")\n    if load_result['success']:\n        loaded_data = load_result['data']\n        loaded_text = loaded_data['template_text']\n        \n        # Stored variables in JSON\n        stored_vars = loaded_data.get('variables', [])\n        print(f\"   Stored variables in JSON: {stored_vars}\")\n        \n        # Recomputed variables (as done in fixed app.py)\n        recomputed_vars = extract_variables_fixed(loaded_text)\n        print(f\"   Recomputed variables (fixed): {recomputed_vars}\")\n        \n        # Verify no conditional placeholders in recomputed vars\n        has_conditionals = any(v.startswith(\"Conditional:\") for v in recomputed_vars)\n        if not has_conditionals:\n            print(\"   ‚úÖ Recomputed variables correctly exclude conditionals\")\n        else:\n            print(\"   ‚ùå Recomputed variables incorrectly include conditionals\")\n        \n        # Verify all expected variables are present\n        expected_vars = ['FirstName', 'LastName', 'Company', 'AccountID', 'TeamName']\n        all_present = all(v in recomputed_vars for v in expected_vars)\n        if all_present:\n            print(\"   ‚úÖ All expected variables correctly extracted\")\n        else:\n            print(\"   ‚ùå Missing some expected variables\")\n    \n    print()\n    \n    # FIX 3: Verify overwrite detection\n    print(\"3. TESTING OVERWRITE DETECTION\")\n    print(\"-\" * 40)\n    \n    # First save - should NOT be an overwrite\n    first_save = tm.save_template(\n        name=\"Overwrite Test\",\n        template_text=\"Initial template content\",\n        description=\"First save\"\n    )\n    print(f\"   First save: {first_save['message']}\")\n    print(f\"   Is overwrite? {first_save.get('overwrite', False)}\")\n    \n    if not first_save.get('overwrite', False):\n        print(\"   ‚úÖ First save correctly detected as new template\")\n    else:\n        print(\"   ‚ùå First save incorrectly detected as overwrite\")\n    \n    # Second save - SHOULD be an overwrite\n    second_save = tm.save_template(\n        name=\"Overwrite Test\",\n        template_text=\"Updated template content\",\n        description=\"Second save (overwrite)\"\n    )\n    print(f\"   Second save: {second_save['message']}\")\n    print(f\"   Is overwrite? {second_save.get('overwrite', False)}\")\n    \n    if second_save.get('overwrite', False):\n        print(\"   ‚úÖ Second save correctly detected as overwrite\")\n        if \"overwrote existing template\" in second_save['message']:\n            print(\"   ‚úÖ Overwrite message properly displayed\")\n    else:\n        print(\"   ‚ùå Second save not detected as overwrite\")\n    \n    # Verify modified_date is added on overwrite\n    overwrite_data = tm.load_template(\"overwrite_test.json\")\n    if overwrite_data['success'] and 'modified_date' in overwrite_data['data']:\n        print(\"   ‚úÖ Modified date added to overwritten template\")\n    \n    print()\n    \n    # Clean up test templates\n    print(\"4. CLEANUP\")\n    print(\"-\" * 40)\n    tm.delete_template(\"export_test_template.json\")\n    tm.delete_template(\"overwrite_test.json\")\n    print(\"   ‚úÖ Test templates cleaned up\")\n    \n    print(\"\\n\" + \"=\" * 50)\n    print(\"‚úÖ ALL FIXES VERIFIED SUCCESSFULLY!\")\n    print(\"=\" * 50)\n    print(\"\\nSummary of fixes implemented:\")\n    print(\"1. export_template method - Works correctly, exports templates to specified locations\")\n    print(\"2. Variable recomputation - Fixed to exclude conditional placeholders on template load\")\n    print(\"3. Overwrite detection - Added with appropriate messaging and metadata updates\")\n\nif __name__ == \"__main__\":\n    try:\n        test_all_fixes()\n    except Exception as e:\n        print(f\"\\n‚ùå Test failed with error: {e}\")\n        import traceback\n        traceback.print_exc()\n        exit(1)","size_bytes":6013},"test_template_library.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nTest script for the Template Library functionality\n\"\"\"\n\nimport json\nimport os\nfrom pathlib import Path\nfrom template_manager import TemplateManager\n\ndef test_template_manager():\n    \"\"\"Test the TemplateManager functionality\"\"\"\n    print(\"Testing Template Library Functionality\")\n    print(\"=\" * 50)\n    \n    # Initialize template manager\n    tm = TemplateManager()\n    print(\"‚úÖ Template Manager initialized\")\n    \n    # Test 1: List existing templates\n    print(\"\\n1. Listing existing templates...\")\n    templates = tm.list_templates()\n    print(f\"   Found {len(templates)} templates:\")\n    for template in templates:\n        print(f\"   - {template['name']} ({template['filename']})\")\n        print(f\"     Variables: {template['variable_count']}, Has conditionals: {template['has_conditionals']}\")\n    \n    # Test 2: Load a template\n    if templates:\n        print(\"\\n2. Loading first template...\")\n        first_template = templates[0]\n        result = tm.load_template(first_template['filename'])\n        if result['success']:\n            data = result['data']\n            print(f\"   ‚úÖ Loaded: {data['name']}\")\n            print(f\"   Variables detected: {', '.join(data.get('variables', []))[:100]}...\")\n            print(f\"   Conditional keys: {', '.join(data.get('conditional_keys', []))}\")\n        else:\n            print(f\"   ‚ùå Error: {result['message']}\")\n    \n    # Test 3: Save a new template\n    print(\"\\n3. Saving a test template...\")\n    test_template = \"\"\"Subject: Test Email - [TestVar]\n\nDear [FirstName] [LastName],\n\nThis is a test template with variables.\n\n[Conditional:Premium]\n\nBest regards,\n[SenderName]\"\"\"\n    \n    result = tm.save_template(\n        name=\"Test Template\",\n        template_text=test_template,\n        description=\"A test template for verification\"\n    )\n    \n    if result['success']:\n        print(f\"   ‚úÖ {result['message']}\")\n        print(f\"   Saved to: {result['filepath']}\")\n    else:\n        print(f\"   ‚ùå Error: {result['message']}\")\n    \n    # Test 4: Verify the saved template appears in list\n    print(\"\\n4. Verifying saved template...\")\n    templates = tm.list_templates()\n    test_template_found = any(t['name'] == 'Test Template' for t in templates)\n    if test_template_found:\n        print(\"   ‚úÖ Test template found in list\")\n    else:\n        print(\"   ‚ùå Test template not found in list\")\n    \n    # Test 5: Delete the test template\n    print(\"\\n5. Deleting test template...\")\n    test_filename = \"test_template.json\"\n    if Path(f\"templates/{test_filename}\").exists():\n        result = tm.delete_template(test_filename)\n        if result['success']:\n            print(f\"   ‚úÖ {result['message']}\")\n        else:\n            print(f\"   ‚ùå Error: {result['message']}\")\n    \n    # Test 6: Verify variable extraction\n    print(\"\\n6. Testing variable extraction...\")\n    test_text = \"[Name] works at [Company] in [Department]. [Conditional:VIP]\"\n    variables = tm.extract_variables(test_text)\n    conditional_keys = tm.extract_conditional_keys(test_text)\n    \n    print(f\"   Variables found: {variables}\")\n    print(f\"   Expected: ['Name', 'Company', 'Department']\")\n    print(f\"   ‚úÖ Variable extraction works\" if variables == ['Name', 'Company', 'Department'] else \"   ‚ùå Variable extraction failed\")\n    \n    print(f\"   Conditional keys found: {conditional_keys}\")\n    print(f\"   Expected: ['VIP']\")\n    print(f\"   ‚úÖ Conditional extraction works\" if conditional_keys == ['VIP'] else \"   ‚ùå Conditional extraction failed\")\n    \n    print(\"\\n\" + \"=\" * 50)\n    print(\"Template Library Tests Complete!\")\n    print(\"\\nSummary:\")\n    print(f\"- Templates directory exists: {Path('templates').exists()}\")\n    print(f\"- Sample templates loaded: {len([t for t in templates if 'Investment' in t['name'] or 'Meeting' in t['name'] or 'Partnership' in t['name']])} found\")\n    print(f\"- Save/Load/Delete operations: Working\")\n    print(f\"- Variable extraction: Working\")\n    \n    return True\n\nif __name__ == \"__main__\":\n    try:\n        success = test_template_manager()\n        if success:\n            print(\"\\n‚úÖ All tests passed successfully!\")\n    except Exception as e:\n        print(f\"\\n‚ùå Test failed with error: {e}\")\n        import traceback\n        traceback.print_exc()","size_bytes":4267},"attached_assets/email_file_generator_1757692481627.py":{"content":"import os\nimport re\nimport mimetypes\nfrom email.message import EmailMessage\nimport pandas as pd\nimport json\ntry:\n    import win32com.client\n    OUTLOOK_AVAILABLE = True\nexcept ImportError:\n    OUTLOOK_AVAILABLE = False\n    print(\"Warning: win32com not available. Install with: pip install pywin32\")\n\n\ndef extract_variables(template_text):\n    \"\"\"Return a list of variables like ['FirstName', 'Company'] found in the template.\"\"\"\n    return re.findall(r\"\\[([^\\]]+)\\]\", template_text)\n\n\ndef apply_text_formatting(text):\n    \"\"\"Apply text formatting like bold, italic, etc.\"\"\"\n    if not text:\n        return text\n    \n    # Convert markdown-style formatting to HTML\n    # **text** -> <b>text</b> (bold)\n    text = re.sub(r'\\*\\*(.*?)\\*\\*', r'<b>\\1</b>', text)\n    # *text* -> <i>text</i> (italic)\n    text = re.sub(r'\\*(.*?)\\*', r'<i>\\1</i>', text)\n    # __text__ -> <u>text</u> (underline)\n    text = re.sub(r'__(.*?)__', r'<u>\\1</u>', text)\n    \n    return text\n\n\ndef convert_to_html_email(text):\n    \"\"\"Convert plain text to HTML format for email.\"\"\"\n    if not text:\n        return text\n    \n    # Apply text formatting first\n    text = apply_text_formatting(text)\n    \n    # Convert line breaks to HTML\n    text = text.replace('\\n', '<br>')\n    \n    # Wrap in basic HTML structure\n    html_body = f\"\"\"<html>\n<head>\n<meta charset=\"UTF-8\">\n</head>\n<body style=\"font-family: Arial, sans-serif; font-size: 11pt;\">\n{text}\n</body>\n</html>\"\"\"\n    \n    return html_body\n\n\ndef clean_email_encoding(text):\n    \"\"\"Clean up email encoding artifacts like quoted-printable characters.\"\"\"\n    if not text:\n        return text\n    \n    # Remove quoted-printable encoding artifacts\n    text = text.replace('=\\n', '')  # Remove soft line breaks\n    text = text.replace('=\\r\\n', '')  # Remove soft line breaks (Windows)\n    text = text.replace('=\\r', '')  # Remove soft line breaks (Mac)\n    \n    # Common quoted-printable encoded characters\n    replacements = {\n        '=20': ' ',    # space\n        '=3D': '=',    # equals sign\n        '=0A': '\\n',   # newline\n        '=0D': '\\r',   # carriage return\n        '=22': '\"',    # double quote\n        '=27': \"'\",    # single quote\n        '=2C': ',',    # comma\n        '=3B': ';',    # semicolon\n        '=3A': ':',    # colon\n        '=2E': '.',    # period\n        '=2D': '-',    # hyphen\n        '=5F': '_',    # underscore\n        '=40': '@',    # at symbol\n        '=24': '$',    # dollar sign\n        '=25': '%',    # percent sign\n        '=26': '&',    # ampersand\n        '=2B': '+',    # plus sign\n        '=3C': '<',    # less than\n        '=3E': '>',    # greater than\n        '=3F': '?',    # question mark\n        '=21': '!',    # exclamation mark\n        '=28': '(',    # left parenthesis\n        '=29': ')',    # right parenthesis\n        '=5B': '[',    # left bracket\n        '=5D': ']',    # right bracket\n        '=7B': '{',    # left brace\n        '=7D': '}',    # right brace\n        '=7C': '|',    # pipe\n        '=5C': '\\\\',   # backslash\n        '=2F': '/',    # forward slash\n        '=7E': '~',    # tilde\n    }\n    \n    for encoded, decoded in replacements.items():\n        text = text.replace(encoded, decoded)\n    \n    # Remove any remaining stray = characters that might be encoding artifacts\n    # But be careful not to remove legitimate = signs in content\n    # Only remove = that appear at line breaks or followed by unusual characters\n    text = re.sub(r'=(?=\\s|$)', '', text)  # Remove = at end of lines or before whitespace\n    \n    return text\n\n\ndef fill_template(template_text, row, variables):\n    \"\"\"Fill template placeholders with row values, leaving placeholders if missing.\"\"\"\n    result = template_text\n    for var in variables:\n        if var in row and pd.notna(row[var]):\n            value = str(row[var])\n            # Clean encoding artifacts from the value\n            value = clean_email_encoding(value)\n            result = result.replace(f\"[{var}]\", value)\n    \n    # Clean the final result as well\n    result = clean_email_encoding(result)\n    return result\n\n\ndef parse_email_addresses(email_str):\n    \"\"\"\n    Parse comma-separated email addresses and return a list.\n    Ignores any addresses enclosed in square brackets, e.g., [test@example.com],\n    which can be used as a manual circuit breaker to temporarily disable a recipient.\n    \"\"\"\n    if not email_str or pd.isna(email_str):\n        return []\n    \n    # Split by comma, strip whitespace, and filter out bracketed or empty emails\n    emails = [\n        email.strip() \n        for email in str(email_str).split(',') \n        if email.strip() and not (email.strip().startswith('[') and email.strip().endswith(']'))\n    ]\n    return emails\n\n\ndef create_email_message(row, template_text, variables, attachments_dir, attachment_columns, conditional_lines):\n    \"\"\"Create EmailMessage object for a DataFrame row as a clean email (no draft prefixes).\"\"\"\n    msg = EmailMessage()\n\n    # Handle To addresses (clean, no [DRAFT] prefix)\n    to_addresses = parse_email_addresses(row.get('Email') or row.get('email') or row.get('To'))\n    if to_addresses:\n        msg['To'] = ', '.join(to_addresses)\n    \n    # Handle CC addresses (clean, no [DRAFT] prefix)\n    cc_addresses = parse_email_addresses(row.get('CC') or row.get('cc'))\n    # Add default CC address\n    default_cc = '['  # Always CC this address\n    if default_cc:\n        cc_addresses.append(default_cc)\n    if cc_addresses:\n        msg['CC'] = ', '.join(cc_addresses)\n    \n    # Handle BCC addresses (clean, no [DRAFT] prefix)\n    bcc_addresses = parse_email_addresses(row.get('BCC') or row.get('bcc'))\n    if bcc_addresses:\n        msg['BCC'] = ', '.join(bcc_addresses)\n    \n    msg['From'] = row.get('From') or 'sender@example.com'\n    msg['Subject'] = row.get('Subject') or 'No Subject'  # Clean subject, no [DRAFT] prefix\n    \n    # Add some email headers for better compatibility\n    msg['X-Draft-Info'] = 'Generated email - Review before sending'\n\n    # First, fill in the main template placeholders\n    body = fill_template(template_text, row, variables)\n\n    # Second, handle conditional placeholders\n    conditional_placeholders = re.findall(r\"\\[Conditional:([^\\]]+)\\]\", body)\n    for placeholder_key in conditional_placeholders:\n        placeholder_tag = f\"[Conditional:{placeholder_key}]\"\n        replacement_text = \"\" # Default to empty string\n        # Check if the flag is set to 1 in the Excel row\n        if placeholder_key in conditional_lines and placeholder_key in row and row[placeholder_key] == 1:\n            # If so, get the text from the JSON and fill its own placeholders\n            raw_text = conditional_lines[placeholder_key]\n            replacement_text = fill_template(raw_text, row, variables)\n        \n        body = body.replace(placeholder_tag, replacement_text)\n\n    # Set clean email body without draft notices\n    # Support both plain text and HTML\n    html_body = convert_to_html_email(body)\n    msg.set_content(body)  # Plain text version\n    msg.add_alternative(html_body, subtype='html')  # HTML version\n\n    # Attach ALL files from attachments directory (ignoring Excel columns)\n    if attachments_dir and os.path.exists(attachments_dir):\n        for filename in os.listdir(attachments_dir):\n            file_path = os.path.join(attachments_dir, filename)\n            # Only attach files (not directories)\n            if os.path.isfile(file_path):\n                try:\n                    with open(file_path, 'rb') as fh:\n                        data = fh.read()\n                    ctype, _ = mimetypes.guess_type(file_path)\n                    if ctype:\n                        maintype, subtype = ctype.split('/', 1)\n                    else:\n                        maintype, subtype = 'application', 'octet-stream'\n                    msg.add_attachment(data, maintype=maintype, subtype=subtype, filename=filename)\n                    print(f\"  ‚úÖ Attached: {filename}\")\n                except Exception as e:\n                    print(f\"  ‚ùå Failed to attach {filename}: {e}\")\n    \n    # Legacy: Also handle attachment columns if specified (for backward compatibility)\n    for col in attachment_columns:\n        filename = row.get(col)\n        if filename and pd.notna(filename):\n            # Extract just the filename if it's a full path\n            filename_str = str(filename).strip().strip('\"\\'')  # Remove quotes and whitespace\n            base_filename = os.path.basename(filename_str)  # Extract just the filename part\n            file_path = os.path.join(attachments_dir, base_filename)\n            try:\n                with open(file_path, 'rb') as fh:\n                    data = fh.read()\n                ctype, _ = mimetypes.guess_type(file_path)\n                if ctype:\n                    maintype, subtype = ctype.split('/', 1)\n                else:\n                    maintype, subtype = 'application', 'octet-stream'\n                msg.add_attachment(data, maintype=maintype, subtype=subtype, filename=base_filename)\n                print(f\"  ‚úÖ Attached from Excel: {base_filename}\")\n            except FileNotFoundError:\n                print(f\"  ‚ùå Attachment not found: {file_path} (original: {filename})\")\n    return msg\n\n\ndef create_outlook_draft(row, template_text, variables, attachments_dir, attachment_columns, conditional_lines):\n    \"\"\"Create an actual Outlook draft from the row data.\"\"\"\n    if not OUTLOOK_AVAILABLE:\n        raise ImportError(\"win32com.client not available. Install with: pip install pywin32\")\n    \n    try:\n        print(\"  üìß Connecting to Outlook...\", end=\"\", flush=True)\n        outlook = win32com.client.Dispatch(\"Outlook.Application\")\n        print(\" ‚úÖ\")\n        \n        print(\"  üìù Creating email item...\", end=\"\", flush=True)\n        mail = outlook.CreateItem(0)  # 0 = Mail item\n        print(\" ‚úÖ\")\n        \n        # Handle To addresses (original addresses without [DRAFT] prefix for Outlook)\n        to_addresses = parse_email_addresses(row.get('Email') or row.get('email') or row.get('To'))\n        if to_addresses:\n            mail.To = '; '.join(to_addresses)\n        \n        # Handle CC addresses\n        cc_addresses = parse_email_addresses(row.get('CC') or row.get('cc'))\n        # Add default CC address\n        default_cc = '['  # Always CC this address\n        if default_cc:\n            cc_addresses.append(default_cc)\n        if cc_addresses:\n            mail.CC = '; '.join(cc_addresses)\n        \n        # Handle BCC addresses\n        bcc_addresses = parse_email_addresses(row.get('BCC') or row.get('bcc'))\n        if bcc_addresses:\n            mail.BCC = '; '.join(bcc_addresses)\n        \n        # Set sender if specified\n        sender = row.get('From')\n        if sender:\n            try:\n                mail.SentOnBehalfOfName = sender\n            except Exception:\n                print(f\"    ‚ö†Ô∏è Could not set sender to {sender}\")\n        \n        # Set subject (clean, no [DRAFT] prefix since this is already a draft in Outlook)\n        subject = row.get('Subject') or 'No Subject'\n        mail.Subject = subject\n        \n        print(\"  üìÑ Processing email body...\", end=\"\", flush=True)\n        # Process email body\n        body = fill_template(template_text, row, variables)\n        \n        # Handle conditional placeholders\n        conditional_placeholders = re.findall(r\"\\[Conditional:([^\\]]+)\\]\", body)\n        for placeholder_key in conditional_placeholders:\n            placeholder_tag = f\"[Conditional:{placeholder_key}]\"\n            replacement_text = \"\"\n            if placeholder_key in conditional_lines and placeholder_key in row and row[placeholder_key] == 1:\n                raw_text = conditional_lines[placeholder_key]\n                replacement_text = fill_template(raw_text, row, variables)\n            body = body.replace(placeholder_tag, replacement_text)\n        \n        # Set clean email body without draft notices\n        # Convert to HTML for better formatting support\n        html_body = convert_to_html_email(body)\n        mail.HTMLBody = html_body\n        print(\" ‚úÖ\")\n        \n        # Add attachments\n        print(\"  üìé Adding attachments...\", end=\"\", flush=True)\n        attachment_count = 0\n        attachment_debug = []\n        \n        # Attach ALL files from attachments directory (ignoring Excel columns)\n        if attachments_dir and os.path.exists(attachments_dir):\n            for filename in os.listdir(attachments_dir):\n                file_path = os.path.join(attachments_dir, filename)\n                # Only attach files (not directories)\n                if os.path.isfile(file_path):\n                    attachment_debug.append(f\"Trying to attach: {file_path}\")\n                    try:\n                        mail.Attachments.Add(file_path)\n                        attachment_count += 1\n                        attachment_debug.append(f\"‚úÖ Successfully attached: {filename}\")\n                    except Exception as e:\n                        attachment_debug.append(f\"‚ùå Error attaching {file_path}: {e}\")\n        \n        # Legacy: Also handle attachment columns if specified (for backward compatibility)\n        for col in attachment_columns:\n            filename = row.get(col)\n            if filename and pd.notna(filename):\n                filename_str = str(filename).strip().strip('\"\\'')\n                base_filename = os.path.basename(filename_str)\n                file_path = os.path.join(attachments_dir, base_filename)\n                attachment_debug.append(f\"Trying to attach from Excel: {file_path}\")\n                \n                try:\n                    if os.path.exists(file_path):\n                        mail.Attachments.Add(file_path)\n                        attachment_count += 1\n                        attachment_debug.append(f\"‚úÖ Successfully attached from Excel: {base_filename}\")\n                    else:\n                        attachment_debug.append(f\"‚ùå File not found: {file_path}\")\n                except Exception as e:\n                    attachment_debug.append(f\"‚ùå Error attaching {file_path}: {e}\")\n        \n        if attachment_debug:\n            print(f\"\\n    \" + \"\\n    \".join(attachment_debug))\n        \n        print(f\" ‚úÖ ({attachment_count} attached)\")\n        \n        # Save as draft\n        print(\"  üíæ Saving draft...\", end=\"\", flush=True)\n        mail.Save()\n        print(\" ‚úÖ\")\n        \n        return mail, subject\n        \n    except Exception as e:\n        print(f\" ‚ùå\")\n        raise Exception(f\"Failed to create Outlook draft: {e}\")\n\n\ndef sanitize_filename(value):\n    return re.sub(r\"[^A-Za-z0-9_.-]\", \"_\", str(value))\n\n\ndef main(template_path='email_template.txt', excel_path='recipients.xlsx', attachments_dir='attachments', output_dir='generated_emails', conditionals_path='conditional_lines.json', use_outlook=True, create_eml_backup=False):\n    if not os.path.exists(output_dir):\n        os.makedirs(output_dir)\n\n    with open(template_path, 'r', encoding='utf-8') as f:\n        template_text = f.read()\n\n    # Load conditional lines from JSON\n    conditional_lines = {}\n    if os.path.exists(conditionals_path):\n        with open(conditionals_path, 'r', encoding='utf-8') as f:\n            conditional_lines = json.load(f)\n        print(f\"Loaded conditional lines: {list(conditional_lines.keys())}\")\n\n    variables = extract_variables(template_text)\n    # Also consider variables from conditional lines\n    for line in conditional_lines.values():\n        variables.extend(extract_variables(line))\n    variables = sorted(list(set(variables))) # Get unique variables\n    print(f\"Found variables: {variables}\")\n\n    df = pd.read_excel(excel_path)\n    attachment_columns = [c for c in df.columns if c.lower().startswith('attachment')]\n\n    total = len(df)\n    generated_files = []\n    outlook_drafts_created = 0\n    \n    # Check if we should use Outlook\n    if use_outlook and not OUTLOOK_AVAILABLE:\n        print(\"‚ö†Ô∏è Outlook not available, falling back to .eml files only\")\n        use_outlook = False\n        create_eml_backup = True  # Force .eml creation if Outlook not available\n    \n    if use_outlook and create_eml_backup:\n        print(\"üéØ Creating Outlook drafts + backup .eml files...\")\n    elif use_outlook:\n        print(\"üìß Creating Outlook drafts only...\")\n    else:\n        print(\"üìÅ Creating .eml files only...\")\n\n    for idx, row in df.iterrows():\n        success = False\n        subject = row.get('Subject') or f'Email_{idx+1}'\n        first_name = row.get('FirstName', 'Unknown')\n        \n        # Get primary email for reference\n        to_addresses = parse_email_addresses(row.get('Email') or row.get('email') or row.get('To'))\n        primary_email = to_addresses[0] if to_addresses else 'no_email'\n        \n        # Create Outlook draft if available\n        if use_outlook:\n            try:\n                mail, actual_subject = create_outlook_draft(row, template_text, variables, attachments_dir, attachment_columns, conditional_lines)\n                outlook_drafts_created += 1\n                success = True\n                print(f\"[{idx + 1}/{total}] ‚úÖ Outlook Draft: '{actual_subject}' ‚Üí {primary_email}\")\n            except Exception as e:\n                print(f\"[{idx + 1}/{total}] ‚ùå Outlook Draft Failed: {e}\")\n                print(f\"    Falling back to .eml file...\")\n        \n        # Create backup .eml file (conditional based on create_eml_backup parameter)\n        if create_eml_backup or not success:  # Create .eml if requested or if Outlook failed\n            try:\n                # Create .eml message\n                msg = create_email_message(row, template_text, variables, attachments_dir, attachment_columns, conditional_lines)\n                \n                # Create filename based on subject and recipient\n                sanitized_subject = sanitize_filename(subject)[:50]  # Limit length\n                sanitized_email = sanitize_filename(primary_email.replace('@', '_at_'))[:30]\n                index_str = str(idx + 1).zfill(3)\n                \n                file_name = f\"{index_str}_{sanitized_subject}_{sanitized_email}.eml\"\n                file_path = os.path.join(output_dir, file_name)\n                \n                with open(file_path, 'wb') as f:\n                    f.write(msg.as_bytes())\n                generated_files.append(file_name)\n                \n                if not success:  # Only show this if Outlook draft failed\n                    print(f\"[{idx + 1}/{total}] üìÑ .eml Backup: {file_name}\")\n                \n            except Exception as e:\n                print(f\"[{idx + 1}/{total}] ‚ùå .eml Creation Failed: {e}\")\n\n        # Print recipient info\n        all_recipients = []\n        if to_addresses:\n            all_recipients.extend([f\"To: {addr}\" for addr in to_addresses])\n        cc_addresses = parse_email_addresses(row.get('CC') or row.get('cc'))\n        if cc_addresses:\n            all_recipients.extend([f\"CC: {addr}\" for addr in cc_addresses])\n        bcc_addresses = parse_email_addresses(row.get('BCC') or row.get('bcc'))\n        if bcc_addresses:\n            all_recipients.extend([f\"BCC: {addr}\" for addr in bcc_addresses])\n        \n        if all_recipients and not success:  # Only show detailed info if Outlook failed\n            print(f\"    Recipients: {', '.join(all_recipients)}\")\n\n    print(\"\\n\" + \"=\"*60)\n    print(\"‚úÖ GENERATION COMPLETE!\")\n    print(\"=\"*60)\n    \n    if use_outlook:\n        print(f\"üìß Outlook Drafts Created: {outlook_drafts_created}\")\n        print(f\"   ‚û§ Check your Outlook Drafts folder\")\n    \n    print(f\"üìÑ Backup .eml Files: {len(generated_files)}\")\n    print(f\"   ‚û§ Saved to: {output_dir}\")\n    \n    if generated_files:\n        print(f\"\\nüìÅ Generated backup files:\")\n        for name in generated_files[:5]:  # Show first 5\n            print(f\"   ‚Ä¢ {name}\")\n        if len(generated_files) > 5:\n            print(f\"   ... and {len(generated_files) - 5} more\")\n    \n    if use_outlook and outlook_drafts_created > 0:\n        print(f\"\\nüéØ Next Steps:\")\n        print(f\"   1. Open Outlook and check your Drafts folder\")\n        print(f\"   2. Review each draft email\")\n        print(f\"   3. Remove draft warning notices\")\n        print(f\"   4. Send when ready\")\n    \n    print(f\"\\nüìã Summary: {outlook_drafts_created if use_outlook else 0} Outlook drafts + {len(generated_files)} backup files\")\n\n\nif __name__ == '__main__':\n    main()\n\n","size_bytes":20398},"test_attachment_setup.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nTest setup for the per-recipient attachment functionality.\nCreates sample data and folder structure for testing.\n\"\"\"\n\nimport os\nimport pandas as pd\nfrom pathlib import Path\n\ndef create_test_setup():\n    \"\"\"Create test data and folder structure for testing per-recipient attachments.\"\"\"\n    \n    # Create base directories\n    base_dir = Path(\"test_attachments\")\n    base_dir.mkdir(exist_ok=True)\n    \n    # Create sample Excel data\n    data = {\n        'FirstName': ['Alice', 'Bob', 'Charlie', 'Diana'],\n        'LastName': ['Johnson', 'Smith', 'Brown', 'Wilson'],\n        'Email': ['alice@example.com', 'bob@example.com', 'charlie@example.com', 'diana@example.com'],\n        'Company': ['TechCorp', 'DataInc', 'WebSolutions', 'CloudServices'],\n        'Subject': ['Q1 Report', 'Product Update', 'Partnership Proposal', 'Service Agreement'],\n        'PremiumMember': [1, 0, 1, 0],  # Conditional flag\n    }\n    \n    df = pd.DataFrame(data)\n    df.to_excel('test_recipients.xlsx', index=False)\n    print(\"‚úÖ Created test_recipients.xlsx\")\n    \n    # Create per-recipient folders and sample files\n    for firstname in data['FirstName']:\n        recipient_dir = base_dir / firstname\n        recipient_dir.mkdir(exist_ok=True)\n        \n        # Create sample files for each recipient\n        # Alice gets contracts\n        if firstname == 'Alice':\n            with open(recipient_dir / 'Q1_Report_2025.pdf', 'w') as f:\n                f.write(f\"Sample Q1 Report for {firstname}\")\n            with open(recipient_dir / 'Financial_Summary.xlsx', 'w') as f:\n                f.write(f\"Financial data for {firstname}\")\n            print(f\"  üìÅ Created folder: {recipient_dir} with 2 files\")\n        \n        # Bob gets product specs\n        elif firstname == 'Bob':\n            with open(recipient_dir / 'Product_Specs_v2.pdf', 'w') as f:\n                f.write(f\"Product specifications for {firstname}\")\n            with open(recipient_dir / 'Release_Notes.txt', 'w') as f:\n                f.write(f\"Release notes for {firstname}\")\n            with open(recipient_dir / 'Demo_Video_Link.txt', 'w') as f:\n                f.write(f\"Demo video link for {firstname}\")\n            print(f\"  üìÅ Created folder: {recipient_dir} with 3 files\")\n        \n        # Charlie gets partnership docs\n        elif firstname == 'Charlie':\n            with open(recipient_dir / 'Partnership_Agreement.docx', 'w') as f:\n                f.write(f\"Partnership agreement for {firstname}\")\n            with open(recipient_dir / 'Terms_and_Conditions.pdf', 'w') as f:\n                f.write(f\"Terms for {firstname}\")\n            print(f\"  üìÅ Created folder: {recipient_dir} with 2 files\")\n        \n        # Diana's folder is intentionally left empty to test warning\n        else:\n            print(f\"  üìÅ Created folder: {recipient_dir} (empty - for testing)\")\n    \n    # Create global attachments folder\n    global_dir = Path(\"global_attachments\")\n    global_dir.mkdir(exist_ok=True)\n    \n    # Add some global files\n    with open(global_dir / 'Company_Brochure.pdf', 'w') as f:\n        f.write(\"Company brochure - sent to all recipients\")\n    with open(global_dir / 'Newsletter_Jan_2025.pdf', 'w') as f:\n        f.write(\"Monthly newsletter - sent to all recipients\")\n    print(f\"‚úÖ Created global_attachments with 2 files\")\n    \n    # Create sample email template\n    template = \"\"\"Dear [FirstName] [LastName],\n\nI hope this email finds you well. I'm reaching out from [Company] regarding: [Subject].\n\nWe have prepared some important documents for your review. Please find them attached to this email.\n\n[Conditional:PremiumMember]\n\nBest regards,\nYour Sales Team\n\"\"\"\n    \n    with open('test_template.txt', 'w') as f:\n        f.write(template)\n    print(\"‚úÖ Created test_template.txt\")\n    \n    # Create conditional lines\n    conditional_lines = {\n        \"PremiumMember\": \"As a valued Premium Member, you have access to exclusive benefits including priority support and advanced features.\"\n    }\n    \n    import json\n    with open('test_conditional_lines.json', 'w') as f:\n        json.dump(conditional_lines, f, indent=2)\n    print(\"‚úÖ Created test_conditional_lines.json\")\n    \n    print(\"\\n\" + \"=\"*50)\n    print(\"TEST SETUP COMPLETE!\")\n    print(\"=\"*50)\n    print(\"\\nTest the implementation with:\")\n    print(\"1. Template: test_template.txt\")\n    print(\"2. Excel data: test_recipients.xlsx\")\n    print(\"3. Per-recipient attachments: test_attachments/\")\n    print(\"4. Global attachments: global_attachments/\")\n    print(\"5. Conditional lines: test_conditional_lines.json\")\n    print(\"\\nFolder structure created:\")\n    print(\"  test_attachments/Alice/ (2 files)\")\n    print(\"  test_attachments/Bob/ (3 files)\")\n    print(\"  test_attachments/Charlie/ (2 files)\")\n    print(\"  test_attachments/Diana/ (empty - for testing warnings)\")\n    print(\"  global_attachments/ (2 files)\")\n    print(\"\\nYou can now:\")\n    print(\"1. Run the Streamlit app\")\n    print(\"2. Load the test template\")\n    print(\"3. Upload test_recipients.xlsx\")\n    print(\"4. Switch between Global and Per-Recipient attachment modes\")\n    print(\"5. Select 'FirstName' as the identifier column in Per-Recipient mode\")\n    print(\"6. Preview and generate emails to test the functionality\")\n\nif __name__ == \"__main__\":\n    create_test_setup()","size_bytes":5314},"app.py":{"content":"import streamlit as st\nimport pandas as pd\nimport json\nimport os\nimport re\nfrom pathlib import Path\nimport tempfile\nimport shutil\nfrom typing import Dict, List, Optional, Any, Tuple\nfrom streamlit_quill import st_quill\nimport html\nimport base64\nimport traceback\n\n# Import the existing email generator functionality\nimport email_file_generator as efg\nfrom template_manager import TemplateManager\nfrom datetime import datetime, timedelta\n\n# Import error handling utilities\nfrom error_handler import (\n    ErrorHandler, SafeOperation, error_handler,\n    validate_email_address, validate_file_size, \n    validate_template_syntax, create_diagnostic_report\n)\n\n# Import recovery utilities\ntry:\n    from recovery_utils import (\n        session_recovery, display_error_dashboard, \n        display_diagnostic_panel, ApplicationDiagnostics\n    )\n    RECOVERY_AVAILABLE = True\nexcept ImportError:\n    RECOVERY_AVAILABLE = False\n    print(\"Recovery utilities not available\")\n\n# Configure page\nst.set_page_config(\n    page_title=\"Email Generator Workflow\",\n    page_icon=\"üìß\",\n    layout=\"wide\",\n    initial_sidebar_state=\"expanded\"\n)\n\n# Initialize session state with error handling\ntry:\n    if 'template_text' not in st.session_state:\n        st.session_state.template_text = \"\"\n    if 'excel_data' not in st.session_state:\n        st.session_state.excel_data = None\n    if 'template_variables' not in st.session_state:\n        st.session_state.template_variables = []\n    if 'conditional_lines' not in st.session_state:\n        st.session_state.conditional_lines = {}\n    if 'attachments_dir' not in st.session_state:\n        st.session_state.attachments_dir = None\n    if 'output_dir' not in st.session_state:\n        st.session_state.output_dir = Path.cwd() / \"generated_emails\"\n    if 'current_step' not in st.session_state:\n        st.session_state.current_step = 1\n    if 'template_manager' not in st.session_state:\n        st.session_state.template_manager = TemplateManager()\n    if 'template_mode' not in st.session_state:\n        st.session_state.template_mode = \"plain\"  # \"plain\" or \"rich\"\n    if 'template_html' not in st.session_state:\n        st.session_state.template_html = \"\"\n    if 'rich_text_content' not in st.session_state:\n        st.session_state.rich_text_content = \"\"\n    if 'attachment_mode' not in st.session_state:\n        st.session_state.attachment_mode = \"global\"  # \"global\" or \"per_recipient\"\n    if 'attachment_identifier_column' not in st.session_state:\n        st.session_state.attachment_identifier_column = None\n    if 'per_recipient_attachments_base' not in st.session_state:\n        st.session_state.per_recipient_attachments_base = None\n    if 'generated_emails' not in st.session_state:\n        st.session_state.generated_emails = []\n    if 'error_handler' not in st.session_state:\n        st.session_state.error_handler = error_handler\n    if 'last_auto_save' not in st.session_state:\n        st.session_state.last_auto_save = datetime.now()\n    if 'safe_mode' not in st.session_state:\n        st.session_state.safe_mode = False\nexcept Exception as e:\n    st.error(f\"Failed to initialize session state: {str(e)}\")\n    error_handler.log_error(e, \"Session Initialization\", severity=\"CRITICAL\")\n\n@SafeOperation(error_handler, \"Template Variable Extraction\")\ndef extract_variables(template_text: str) -> List[str]:\n    \"\"\"Extract variables from template text with error handling\"\"\"\n    try:\n        if not template_text:\n            return []\n        \n        # Validate template syntax first\n        is_valid, errors = validate_template_syntax(template_text)\n        if not is_valid:\n            error_msg = \"Template syntax errors: \" + \"; \".join(errors)\n            raise ValueError(error_msg)\n        \n        # Extract variables\n        all_vars = re.findall(r\"\\[([^\\]]+)\\]\", template_text)\n        # Filter out conditional placeholders\n        regular_vars = [var for var in all_vars if not var.startswith(\"Conditional:\")]\n        return regular_vars\n    except Exception as e:\n        error_handler.log_error(e, \"Extract Variables\")\n        return []\n\ndef convert_html_to_plain(html_content: str) -> str:\n    \"\"\"Convert HTML content to plain text while preserving placeholders.\"\"\"\n    if not html_content:\n        return \"\"\n    \n    # Remove HTML tags but preserve content\n    import re\n    # First, replace <br> and </p> with newlines\n    text = html_content.replace('<br>', '\\n').replace('<br/>', '\\n').replace('<br />', '\\n')\n    text = text.replace('</p>', '\\n').replace('</div>', '\\n')\n    \n    # Remove all other HTML tags\n    text = re.sub(r'<[^>]+>', '', text)\n    \n    # Decode HTML entities\n    text = html.unescape(text)\n    \n    # Clean up excessive newlines\n    text = re.sub(r'\\n{3,}', '\\n\\n', text)\n    \n    return text.strip()\n\ndef convert_plain_to_html(plain_text: str) -> str:\n    \"\"\"Convert plain text to HTML format.\"\"\"\n    if not plain_text:\n        return \"\"\n    \n    # Escape HTML special characters but preserve placeholders\n    lines = plain_text.split('\\n')\n    html_lines = []\n    \n    for line in lines:\n        # Don't escape content within brackets (our placeholders)\n        parts = re.split(r'(\\[[^\\]]+\\])', line)\n        escaped_parts = []\n        for part in parts:\n            if part.startswith('[') and part.endswith(']'):\n                # This is a placeholder, keep it as-is\n                escaped_parts.append(part)\n            else:\n                # Regular text, escape HTML\n                escaped_parts.append(html.escape(part))\n        html_lines.append(''.join(escaped_parts))\n    \n    # Join lines with <br> tags\n    return '<br>'.join(html_lines)\n\ndef create_html_preview(html_content: str) -> str:\n    \"\"\"Create a preview of the HTML email with basic styling.\"\"\"\n    preview_html = f\"\"\"\n    <html>\n    <head>\n        <style>\n            body {{\n                font-family: Arial, sans-serif;\n                font-size: 14px;\n                line-height: 1.6;\n                padding: 20px;\n                background-color: #ffffff;\n            }}\n            a {{\n                color: #0066cc;\n                text-decoration: none;\n            }}\n            a:hover {{\n                text-decoration: underline;\n            }}\n            ul, ol {{\n                margin-left: 20px;\n            }}\n            .placeholder {{\n                background-color: #fffacd;\n                padding: 2px 4px;\n                border-radius: 3px;\n                font-family: monospace;\n            }}\n        </style>\n    </head>\n    <body>\n        {html_content}\n    </body>\n    </html>\n    \"\"\"\n    return preview_html\n\ndef validate_excel_columns(df: pd.DataFrame, required_vars: List[str]) -> Dict[str, Any]:\n    \"\"\"Validate Excel columns against template variables with comprehensive error checking\"\"\"\n    try:\n        if df is None or df.empty:\n            return {\n                'has_email': False,\n                'missing_vars': required_vars,\n                'available_cols': [],\n                'is_valid': False,\n                'error': 'DataFrame is empty or None'\n            }\n        \n        missing_vars = []\n        available_cols = df.columns.tolist()\n        invalid_emails = []\n        \n        # Check for email column\n        email_cols = ['Email', 'email', 'To', 'to']\n        email_col = None\n        for col in email_cols:\n            if col in available_cols:\n                email_col = col\n                break\n        \n        has_email = email_col is not None\n        \n        # Validate email addresses if email column exists\n        if has_email:\n            for idx, row in df.iterrows():\n                email = row.get(email_col, '')\n                # Handle NaN and None values\n                if pd.isna(email) or email == '':\n                    continue  # Skip empty email rows\n                email = str(email).strip()\n                if not email:\n                    continue  # Skip whitespace-only emails\n                is_valid, error = validate_email_address(email)\n                if not is_valid:\n                    invalid_emails.append(f\"Row {idx+1}: {error}\")\n        \n        # Check for required template variables\n        for var in required_vars:\n            if var not in available_cols:\n                missing_vars.append(var)\n        \n        # Check for Subject column\n        has_subject = 'Subject' in available_cols or 'subject' in available_cols\n        \n        return {\n            'has_email': has_email,\n            'has_subject': has_subject,\n            'missing_vars': missing_vars,\n            'available_cols': available_cols,\n            'invalid_emails': invalid_emails[:5],  # Show first 5 invalid emails\n            'is_valid': has_email and len(missing_vars) == 0 and len(invalid_emails) == 0\n        }\n    except Exception as e:\n        error_handler.log_error(e, \"Excel Validation\")\n        return {\n            'has_email': False,\n            'missing_vars': required_vars,\n            'available_cols': [],\n            'is_valid': False,\n            'error': str(e)\n        }\n\ndef create_preview_email(row: pd.Series, template_text: str, variables: List[str], conditional_lines: Dict[str, str], is_html: bool = False) -> str:\n    \"\"\"Create a preview of what the email would look like for a given row\"\"\"\n    # Use HTML template if in rich text mode\n    if is_html and st.session_state.template_mode == \"rich\" and st.session_state.template_html:\n        template_to_use = st.session_state.template_html\n    else:\n        template_to_use = template_text\n    \n    # Fill template with row data\n    preview = efg.fill_template(template_to_use, row, variables)\n    \n    # Handle conditional placeholders\n    conditional_placeholders = re.findall(r\"\\[Conditional:([^\\]]+)\\]\", preview)\n    for placeholder_key in conditional_placeholders:\n        placeholder_tag = f\"[Conditional:{placeholder_key}]\"\n        replacement_text = \"\"\n        if placeholder_key in conditional_lines and placeholder_key in row and row[placeholder_key] == 1:\n            raw_text = conditional_lines[placeholder_key]\n            replacement_text = efg.fill_template(raw_text, row, variables)\n        preview = preview.replace(placeholder_tag, replacement_text)\n    \n    return preview\n\ndef main():\n    st.title(\"üìß Email Generator Workflow\")\n    st.markdown(\"Generate personalized emails from templates with Outlook integration\")\n    \n    # Sidebar for navigation\n    with st.sidebar:\n        st.header(\"Workflow Steps\")\n        \n        # Step indicators\n        steps = [\n            \"1. Template Setup\",\n            \"2. Excel Data Upload\", \n            \"3. Variable Mapping\",\n            \"4. Attachments\",\n            \"5. Conditional Content\",\n            \"6. Preview & Generate\"\n        ]\n        \n        for i, step in enumerate(steps, 1):\n            if i == st.session_state.current_step:\n                st.markdown(f\"**‚ñ∂Ô∏è {step}**\")\n            elif i < st.session_state.current_step:\n                st.markdown(f\"‚úÖ {step}\")\n            else:\n                st.markdown(f\"‚è∏Ô∏è {step}\")\n        \n        st.divider()\n        \n        # Output directory setting\n        st.subheader(\"Output Settings\")\n        output_path = st.text_input(\"Output Directory\", value=str(st.session_state.output_dir))\n        if output_path != str(st.session_state.output_dir):\n            st.session_state.output_dir = Path(output_path)\n        \n        # Create output directory if it doesn't exist\n        st.session_state.output_dir.mkdir(exist_ok=True)\n        st.success(f\"Output: {st.session_state.output_dir}\")\n        \n        st.divider()\n        \n        # Template Library Section\n        st.header(\"üìö Template Library\")\n        \n        # List available templates\n        templates = st.session_state.template_manager.list_templates()\n        \n        if templates:\n            st.subheader(\"Available Templates\")\n            for template in templates:\n                format_icon = \"üé®\" if template.get('format_type', 'plain') == 'rich' else \"üìÑ\"\n                with st.expander(f\"{format_icon} {template['name']}\" + (\" üîÄ\" if template['has_conditionals'] else \"\")):\n                    st.markdown(f\"**Description:** {template['description']}\")\n                    st.markdown(f\"**Created:** {template['created_date']}\")\n                    st.markdown(f\"**Variables:** {template['variable_count']}\")\n                    st.markdown(f\"**Format:** {template.get('format_type', 'plain').title()} Text\")\n                    \n                    col1, col2 = st.columns(2)\n                    with col1:\n                        if st.button(f\"Load\", key=f\"load_{template['filename']}\", use_container_width=True):\n                            result = st.session_state.template_manager.load_template(template['filename'])\n                            if result['success']:\n                                data = result['data']\n                                # Load template text\n                                st.session_state.template_text = data['template_text']\n                                # Load format type\n                                st.session_state.template_mode = data.get('format_type', 'plain')\n                                # Load HTML if available\n                                if st.session_state.template_mode == 'rich' and 'template_html' in data:\n                                    st.session_state.template_html = data['template_html']\n                                    st.session_state.rich_text_content = data['template_html']\n                                else:\n                                    st.session_state.template_html = \"\"\n                                    st.session_state.rich_text_content = \"\"\n                                # Recompute variables from the loaded template text to ensure consistency\n                                st.session_state.template_variables = extract_variables(data['template_text'])\n                                # Load conditional lines if present\n                                if 'conditional_keys' in data:\n                                    # Prepare default conditional lines for the loaded template\n                                    for key in data['conditional_keys']:\n                                        if key not in st.session_state.conditional_lines:\n                                            st.session_state.conditional_lines[key] = f\"As a valued {key} member, you have access to exclusive benefits.\"\n                                st.success(f\"Loaded template: {template['name']}\")\n                                st.session_state.current_step = 1  # Go to template setup\n                                st.rerun()\n                            else:\n                                st.error(result['message'])\n                    \n                    with col2:\n                        # Use a popover for delete confirmation\n                        with st.popover(\"Delete\", use_container_width=True):\n                            st.warning(f\"Delete '{template['name']}'?\")\n                            if st.button(\"Confirm Delete\", key=f\"confirm_delete_{template['filename']}\", type=\"primary\"):\n                                result = st.session_state.template_manager.delete_template(template['filename'])\n                                if result['success']:\n                                    st.success(result['message'])\n                                    st.rerun()\n                                else:\n                                    st.error(result['message'])\n        else:\n            st.info(\"No saved templates yet. Create and save your first template!\")\n        \n        # Save current template section\n        st.divider()\n        st.subheader(\"üíæ Save Current Template\")\n        \n        if st.session_state.template_text:\n            template_name = st.text_input(\n                \"Template Name\",\n                placeholder=\"e.g., Sales Outreach\",\n                key=\"save_template_name\"\n            )\n            \n            template_description = st.text_area(\n                \"Description (optional)\",\n                placeholder=\"Brief description of this template\",\n                height=60,\n                key=\"save_template_description\"\n            )\n            \n            if st.button(\"üíæ Save to Library\", use_container_width=True):\n                if template_name:\n                    result = st.session_state.template_manager.save_template(\n                        name=template_name,\n                        template_text=st.session_state.template_text,\n                        description=template_description,\n                        format_type=st.session_state.template_mode,\n                        template_html=st.session_state.template_html if st.session_state.template_mode == \"rich\" else None\n                    )\n                    if result['success']:\n                        st.success(result['message'])\n                        st.balloons()\n                        st.rerun()\n                    else:\n                        st.error(result['message'])\n                else:\n                    st.error(\"Please enter a template name\")\n        else:\n            st.info(\"Create a template first to save it to the library\")\n\n    # Main content area\n    if st.session_state.current_step == 1:\n        step_1_template_setup()\n    elif st.session_state.current_step == 2:\n        step_2_excel_upload()\n    elif st.session_state.current_step == 3:\n        step_3_variable_mapping()\n    elif st.session_state.current_step == 4:\n        step_4_attachments()\n    elif st.session_state.current_step == 5:\n        step_5_conditional_content()\n    elif st.session_state.current_step == 6:\n        step_6_preview_generate()\n\ndef step_1_template_setup():\n    st.header(\"1. Template Setup\")\n    st.markdown(\"Create or edit your email template with variable placeholders like `[FirstName]`\")\n    \n    # Template mode toggle\n    mode_col1, mode_col2, mode_col3 = st.columns([1, 2, 2])\n    with mode_col1:\n        template_mode = st.radio(\n            \"Template Mode\",\n            options=[\"plain\", \"rich\"],\n            format_func=lambda x: \"Plain Text\" if x == \"plain\" else \"Rich Text\",\n            index=0 if st.session_state.template_mode == \"plain\" else 1,\n            help=\"Choose between plain text or rich text editing with formatting options\"\n        )\n        \n        if template_mode != st.session_state.template_mode:\n            st.session_state.template_mode = template_mode\n            # Convert content when switching modes\n            if template_mode == \"rich\" and st.session_state.template_text:\n                # Convert plain text to HTML\n                st.session_state.template_html = convert_plain_to_html(st.session_state.template_text)\n                st.session_state.rich_text_content = st.session_state.template_html\n            elif template_mode == \"plain\" and st.session_state.template_html:\n                # Convert HTML to plain text\n                st.session_state.template_text = convert_html_to_plain(st.session_state.template_html)\n            st.rerun()\n    \n    with mode_col2:\n        if st.session_state.template_mode == \"rich\":\n            st.info(\"üìù Rich Text Mode: Use the toolbar to format your email. Variables like [FirstName] work in rich text too!\")\n        else:\n            st.info(\"üìÑ Plain Text Mode: Simple text editing with variable placeholders.\")\n    \n    col1, col2 = st.columns([2, 1])\n    \n    with col1:\n        if st.session_state.template_mode == \"plain\":\n            # Plain text editor\n            template_text = st.text_area(\n                \"Email Template\",\n                value=st.session_state.template_text,\n                height=400,\n                help=\"Use [VariableName] for placeholders. Use [Conditional:KeyName] for conditional content.\"\n            )\n            \n            if template_text != st.session_state.template_text:\n                st.session_state.template_text = template_text\n                st.session_state.template_variables = extract_variables(template_text) if template_text else []\n                st.rerun()\n        else:\n            # Rich text editor\n            st.markdown(\"### Email Template Editor\")\n            st.markdown(\"üí° **Tip:** Type `[FirstName]`, `[Company]` etc. for variable placeholders\")\n            \n            # Quill editor configuration\n            quill_toolbar = [\n                ['bold', 'italic', 'underline', 'strike'],\n                [{'size': ['small', False, 'large', 'huge']}],\n                [{'color': []}, {'background': []}],\n                [{'list': 'ordered'}, {'list': 'bullet'}],\n                ['link', 'blockquote'],\n                [{'align': []}],\n                ['clean']\n            ]\n            \n            # Rich text editor\n            content = st_quill(\n                value=st.session_state.rich_text_content,\n                html=True,\n                toolbar=quill_toolbar,\n                key=\"rich_editor\"\n            )\n            \n            if content != st.session_state.rich_text_content:\n                st.session_state.rich_text_content = content\n                st.session_state.template_html = content\n                # Extract plain text version for variable detection\n                plain_version = convert_html_to_plain(content)\n                st.session_state.template_text = plain_version\n                st.session_state.template_variables = extract_variables(plain_version) if plain_version else []\n            \n            # HTML Preview\n            if st.session_state.template_html:\n                st.markdown(\"### üëÅÔ∏è HTML Preview\")\n                # Create an iframe-like preview\n                preview_html = create_html_preview(st.session_state.template_html)\n                st.components.v1.html(preview_html, height=300, scrolling=True)\n    \n    with col2:\n        st.subheader(\"Detected Variables\")\n        if st.session_state.template_variables:\n            for var in st.session_state.template_variables:\n                if var.startswith('Conditional:'):\n                    st.markdown(f\"üîÄ `{var}` (conditional)\")\n                else:\n                    st.markdown(f\"üìù `{var}`\")\n        else:\n            st.info(\"No variables detected\")\n        \n        # Template actions\n        st.subheader(\"Quick Actions\")\n        \n        # Load from file\n        file_types = ['txt', 'html'] if st.session_state.template_mode == \"rich\" else ['txt']\n        uploaded_template = st.file_uploader(\n            f\"Upload Template (.{'/'.join(file_types)})\", \n            type=file_types, \n            key=\"upload_template\"\n        )\n        if uploaded_template:\n            content = uploaded_template.read().decode('utf-8')\n            if st.session_state.template_mode == \"rich\" and uploaded_template.name.endswith('.html'):\n                st.session_state.template_html = content\n                st.session_state.rich_text_content = content\n                st.session_state.template_text = convert_html_to_plain(content)\n            else:\n                st.session_state.template_text = content\n                if st.session_state.template_mode == \"rich\":\n                    st.session_state.template_html = convert_plain_to_html(content)\n                    st.session_state.rich_text_content = st.session_state.template_html\n            st.session_state.template_variables = extract_variables(st.session_state.template_text)\n            st.success(\"‚úÖ Template loaded from file!\")\n            st.rerun()\n        \n        # Quick save to library\n        if st.session_state.template_text:\n            st.info(\"üí° Use the Template Library in the sidebar to save this template\")\n        \n        # Export template\n        export_format = st.selectbox(\n            \"Export Format\",\n            options=[\"txt\", \"html\"] if st.session_state.template_mode == \"rich\" else [\"txt\"],\n            key=\"export_format\"\n        )\n        \n        if st.button(\"üì• Export Template\"):\n            if st.session_state.template_text:\n                timestamp = pd.Timestamp.now().strftime('%Y%m%d_%H%M%S')\n                if export_format == \"html\" and st.session_state.template_mode == \"rich\":\n                    template_path = st.session_state.output_dir / f\"template_{timestamp}.html\"\n                    with open(template_path, 'w', encoding='utf-8') as f:\n                        f.write(st.session_state.template_html)\n                else:\n                    template_path = st.session_state.output_dir / f\"template_{timestamp}.txt\"\n                    with open(template_path, 'w', encoding='utf-8') as f:\n                        f.write(st.session_state.template_text)\n                st.success(f\"Exported to: {template_path}\")\n            else:\n                st.warning(\"No template to export\")\n        \n        # Formatting tips\n        if st.session_state.template_mode == \"rich\":\n            with st.expander(\"üìñ Rich Text Tips\"):\n                st.markdown(\"\"\"\n                **Variable Placeholders:**\n                - Type `[FirstName]`, `[Company]` etc. directly\n                - They'll be highlighted in the preview\n                \n                **Formatting:**\n                - Select text and use toolbar buttons\n                - Bold: **Ctrl/Cmd + B**\n                - Italic: *Ctrl/Cmd + I*\n                - Underline: Ctrl/Cmd + U\n                \n                **Links:**\n                - Select text and click the link button\n                - Enter the URL in the popup\n                \n                **Lists:**\n                - Use the list buttons in the toolbar\n                - Press Enter for new items\n                \"\"\")\n    \n    # Navigation\n    st.divider()\n    col1, col2, col3 = st.columns([1, 1, 1])\n    with col3:\n        # Check if we have content based on mode\n        has_content = (st.session_state.template_text if st.session_state.template_mode == \"plain\" \n                      else st.session_state.template_html)\n        if st.button(\"Next: Excel Upload ‚ñ∂Ô∏è\", disabled=not has_content):\n            st.session_state.current_step = 2\n            st.rerun()\n\ndef step_2_excel_upload():\n    st.header(\"2. Excel Data Upload\")\n    st.markdown(\"Upload your Excel file containing recipient data\")\n    \n    # File upload\n    uploaded_file = st.file_uploader(\"Upload Excel File\", type=['xlsx', 'xls'])\n    \n    if uploaded_file:\n        try:\n            # Read Excel file\n            df = pd.read_excel(uploaded_file)\n            st.session_state.excel_data = df\n            \n            st.success(f\"‚úÖ Loaded {len(df)} rows from Excel file\")\n            \n            # Display data preview\n            st.subheader(\"Data Preview\")\n            st.dataframe(df.head(10), use_container_width=True)\n            \n            # Show column info\n            st.subheader(\"Column Information\")\n            col_info = []\n            for col in df.columns:\n                non_null_count = df[col].count()\n                col_info.append({\n                    'Column': col,\n                    'Non-null Count': non_null_count,\n                    'Data Type': str(df[col].dtype),\n                    'Sample Values': ', '.join([str(x) for x in df[col].dropna().head(3).tolist()])\n                })\n            \n            st.dataframe(pd.DataFrame(col_info), use_container_width=True)\n            \n        except Exception as e:\n            st.error(f\"Error reading Excel file: {str(e)}\")\n            st.session_state.excel_data = None\n    \n    elif st.session_state.excel_data is not None:\n        st.info(\"Excel data already loaded\")\n        st.dataframe(st.session_state.excel_data.head(5), use_container_width=True)\n    \n    # Navigation\n    st.divider()\n    col1, col2, col3 = st.columns([1, 1, 1])\n    with col1:\n        if st.button(\"‚óÄÔ∏è Back: Template\"):\n            st.session_state.current_step = 1\n            st.rerun()\n    with col3:\n        if st.button(\"Next: Variable Mapping ‚ñ∂Ô∏è\", disabled=st.session_state.excel_data is None):\n            st.session_state.current_step = 3\n            st.rerun()\n\ndef step_3_variable_mapping():\n    st.header(\"3. Variable Mapping Verification\")\n    st.markdown(\"Verify that your Excel columns match the template variables\")\n    \n    if st.session_state.excel_data is None:\n        st.error(\"Please upload Excel data first\")\n        return\n    \n    # Validate columns\n    validation = validate_excel_columns(st.session_state.excel_data, st.session_state.template_variables)\n    \n    col1, col2 = st.columns(2)\n    \n    with col1:\n        st.subheader(\"Template Variables\")\n        if st.session_state.template_variables:\n            for var in st.session_state.template_variables:\n                if var in validation['available_cols']:\n                    st.success(f\"‚úÖ `{var}` - Found in Excel\")\n                else:\n                    st.error(f\"‚ùå `{var}` - Missing from Excel\")\n        else:\n            st.info(\"No template variables detected\")\n    \n    with col2:\n        st.subheader(\"Excel Columns\")\n        for col in validation['available_cols']:\n            if col in st.session_state.template_variables:\n                st.success(f\"‚úÖ `{col}` - Used in template\")\n            elif col.lower() in ['email', 'to', 'cc', 'bcc', 'from', 'subject']:\n                st.info(f\"üìß `{col}` - Email field\")\n            elif col in st.session_state.conditional_lines:\n                st.info(f\"üîÄ `{col}` - Conditional flag\")\n            else:\n                st.warning(f\"‚ö†Ô∏è `{col}` - Not used\")\n    \n    # Email validation\n    st.subheader(\"Email Configuration Check\")\n    if validation['has_email']:\n        st.success(\"‚úÖ Email column found\")\n    else:\n        st.error(\"‚ùå No email column found (need 'Email', 'email', 'To', or 'to')\")\n    \n    # Show mapping issues\n    if validation['missing_vars']:\n        st.error(\"‚ùå Missing variables in Excel data:\")\n        for var in validation['missing_vars']:\n            st.write(f\"- `{var}`\")\n        st.markdown(\"**Fix:** Add these columns to your Excel file or remove the variables from your template\")\n    \n    # Show invalid email addresses\n    if validation.get('invalid_emails'):\n        st.error(\"‚ùå Invalid email addresses found:\")\n        for email_error in validation['invalid_emails']:\n            st.write(f\"- {email_error}\")\n        st.markdown(\"**Fix:** Correct the email addresses in your Excel file\")\n    \n    # Navigation\n    st.divider()\n    col1, col2, col3 = st.columns([1, 1, 1])\n    with col1:\n        if st.button(\"‚óÄÔ∏è Back: Excel Upload\"):\n            st.session_state.current_step = 2\n            st.rerun()\n    with col3:\n        if st.button(\"Next: Attachments ‚ñ∂Ô∏è\", disabled=not validation['is_valid']):\n            st.session_state.current_step = 4\n            st.rerun()\n\ndef step_4_attachments():\n    st.header(\"4. Attachments Configuration\")\n    st.markdown(\"Configure attachments for your emails\")\n    \n    # Attachment mode selection\n    st.subheader(\"Attachment Mode\")\n    attachment_mode = st.radio(\n        \"Select how to attach files:\",\n        options=[\"global\", \"per_recipient\"],\n        format_func=lambda x: \"Global Attachments (same for all)\" if x == \"global\" else \"Per-Recipient Attachments (individual folders)\",\n        index=0 if st.session_state.attachment_mode == \"global\" else 1,\n        help=\"Global: All recipients get the same attachments. Per-Recipient: Each recipient gets attachments from their own folder.\"\n    )\n    \n    if attachment_mode != st.session_state.attachment_mode:\n        st.session_state.attachment_mode = attachment_mode\n        st.rerun()\n    \n    if st.session_state.attachment_mode == \"global\":\n        # Global attachments mode\n        st.subheader(\"Global Attachments\")\n        st.markdown(\"Select a folder containing files that will be attached to ALL emails\")\n        \n        col1, col2 = st.columns([2, 1])\n        \n        with col1:\n            attachments_path = st.text_input(\n                \"Attachments Folder Path\",\n                value=str(st.session_state.attachments_dir) if st.session_state.attachments_dir else \"\",\n                help=\"Enter the path to the folder containing your attachment files\"\n            )\n            \n            if attachments_path and Path(attachments_path).exists():\n                st.session_state.attachments_dir = Path(attachments_path)\n                \n                # List files in directory\n                files = list(st.session_state.attachments_dir.glob(\"*\"))\n                files = [f for f in files if f.is_file()]\n                \n                if files:\n                    st.success(f\"‚úÖ Found {len(files)} files\")\n                    \n                    # Show file list\n                    file_info = []\n                    for file_path in files:\n                        size_mb = file_path.stat().st_size / (1024 * 1024)\n                        file_info.append({\n                            'Filename': file_path.name,\n                            'Size (MB)': f\"{size_mb:.2f}\",\n                            'Type': file_path.suffix\n                        })\n                    \n                    st.dataframe(pd.DataFrame(file_info), use_container_width=True)\n                else:\n                    st.warning(\"‚ö†Ô∏è No files found in directory\")\n            elif attachments_path:\n                st.error(\"‚ùå Directory not found\")\n        \n        with col2:\n            st.subheader(\"Quick Actions\")\n            \n            # Create attachments directory\n            if st.button(\"üìÅ Create Attachments Folder\"):\n                new_dir = st.session_state.output_dir / \"attachments\"\n                new_dir.mkdir(exist_ok=True)\n                st.session_state.attachments_dir = new_dir\n                st.success(f\"Created: {new_dir}\")\n                st.rerun()\n            \n            # Upload files\n            uploaded_attachments = st.file_uploader(\n                \"Upload Attachment Files\",\n                accept_multiple_files=True,\n                help=\"Upload files to add to the attachments folder\"\n            )\n            \n            if uploaded_attachments and st.session_state.attachments_dir:\n                for uploaded_file in uploaded_attachments:\n                    file_path = st.session_state.attachments_dir / uploaded_file.name\n                    with open(file_path, 'wb') as f:\n                        f.write(uploaded_file.read())\n                    st.success(f\"Saved: {uploaded_file.name}\")\n    \n    else:\n        # Per-recipient attachments mode\n        st.subheader(\"Per-Recipient Attachments\")\n        st.markdown(\"Each recipient gets attachments from their individual folder\")\n        \n        if st.session_state.excel_data is None:\n            st.error(\"Please upload Excel data first to configure per-recipient attachments\")\n            col1, col2, col3 = st.columns([1, 1, 1])\n            with col1:\n                if st.button(\"‚óÄÔ∏è Back: Variable Mapping\"):\n                    st.session_state.current_step = 3\n                    st.rerun()\n            return\n        \n        # Base folder selection\n        col1, col2 = st.columns([2, 1])\n        \n        with col1:\n            base_path = st.text_input(\n                \"Base Attachments Folder\",\n                value=str(st.session_state.per_recipient_attachments_base) if st.session_state.per_recipient_attachments_base else \"\",\n                help=\"Enter the base folder path containing recipient subfolders (e.g., attachments/)\"\n            )\n            \n            if base_path:\n                base_path_obj = Path(base_path)\n                if base_path_obj.exists():\n                    st.session_state.per_recipient_attachments_base = base_path_obj\n                    st.success(f\"‚úÖ Base folder exists: {base_path}\")\n                else:\n                    st.error(f\"‚ùå Base folder not found: {base_path}\")\n        \n        with col2:\n            st.subheader(\"Quick Actions\")\n            if st.button(\"üìÅ Create Base Folder\"):\n                new_base = st.session_state.output_dir / \"attachments\"\n                new_base.mkdir(exist_ok=True)\n                st.session_state.per_recipient_attachments_base = new_base\n                st.success(f\"Created: {new_base}\")\n                st.rerun()\n        \n        # Column selection for folder identifier\n        if st.session_state.per_recipient_attachments_base and st.session_state.per_recipient_attachments_base.exists():\n            st.subheader(\"Folder Identifier Column\")\n            \n            available_columns = st.session_state.excel_data.columns.tolist()\n            \n            # Suggest common identifier columns\n            suggested_columns = ['FirstName', 'LastName', 'Email', 'Name', 'ID', 'CustomerID']\n            suggested_available = [col for col in suggested_columns if col in available_columns]\n            \n            identifier_column = st.selectbox(\n                \"Select the Excel column to use as folder names:\",\n                options=available_columns,\n                index=available_columns.index(st.session_state.attachment_identifier_column) if st.session_state.attachment_identifier_column in available_columns else (available_columns.index(suggested_available[0]) if suggested_available else 0),\n                help=\"This column's values will be used as subfolder names for each recipient\"\n            )\n            \n            if identifier_column != st.session_state.attachment_identifier_column:\n                st.session_state.attachment_identifier_column = identifier_column\n                st.rerun()\n            \n            # Show folder mapping preview\n            if st.session_state.attachment_identifier_column:\n                st.subheader(\"Folder Mapping Preview\")\n                \n                # Create folder mapping\n                folder_mapping = []\n                for idx, row in st.session_state.excel_data.iterrows():\n                    identifier_value = str(row[st.session_state.attachment_identifier_column])\n                    # Clean identifier for folder name (remove special characters)\n                    clean_identifier = re.sub(r'[^\\w\\s-]', '', identifier_value).strip()\n                    if clean_identifier:\n                        folder_path = st.session_state.per_recipient_attachments_base / clean_identifier\n                        \n                        # Check folder existence and count files\n                        exists = folder_path.exists()\n                        file_count = 0\n                        total_size_mb = 0\n                        files_list = []\n                        \n                        if exists:\n                            files = [f for f in folder_path.glob(\"*\") if f.is_file()]\n                            file_count = len(files)\n                            total_size_mb = sum(f.stat().st_size for f in files) / (1024 * 1024)\n                            files_list = [f.name for f in files[:5]]  # Show first 5 files\n                        \n                        folder_mapping.append({\n                            'Recipient': row.get('Email', row.get('email', f'Row {idx+1}')),\n                            'Identifier': identifier_value,\n                            'Folder': clean_identifier,\n                            'Path': str(folder_path),\n                            'Exists': '‚úÖ' if exists else '‚ùå',\n                            'Files': file_count,\n                            'Size (MB)': f\"{total_size_mb:.2f}\" if exists else \"0\",\n                            'Sample Files': ', '.join(files_list[:3]) + ('...' if len(files_list) > 3 else '') if files_list else 'None'\n                        })\n                \n                # Display mapping table\n                if folder_mapping:\n                    df_mapping = pd.DataFrame(folder_mapping)\n                    \n                    # Summary statistics\n                    col1, col2, col3, col4 = st.columns(4)\n                    with col1:\n                        total_recipients = len(folder_mapping)\n                        st.metric(\"Total Recipients\", total_recipients)\n                    with col2:\n                        folders_exist = sum(1 for m in folder_mapping if m['Exists'] == '‚úÖ')\n                        st.metric(\"Folders Found\", f\"{folders_exist}/{total_recipients}\")\n                    with col3:\n                        total_files = sum(m['Files'] for m in folder_mapping)\n                        st.metric(\"Total Files\", total_files)\n                    with col4:\n                        total_size = sum(float(m['Size (MB)']) for m in folder_mapping)\n                        st.metric(\"Total Size\", f\"{total_size:.2f} MB\")\n                    \n                    # Show detailed mapping\n                    st.dataframe(df_mapping, use_container_width=True, height=400)\n                    \n                    # Warnings for missing folders\n                    missing_folders = [m for m in folder_mapping if m['Exists'] == '‚ùå']\n                    if missing_folders:\n                        with st.expander(f\"‚ö†Ô∏è Missing Folders ({len(missing_folders)})\", expanded=True):\n                            st.warning(\"The following recipients don't have attachment folders:\")\n                            for missing in missing_folders[:10]:\n                                st.write(f\"- **{missing['Recipient']}**: Expected folder `{missing['Folder']}`\")\n                            if len(missing_folders) > 10:\n                                st.write(f\"... and {len(missing_folders) - 10} more\")\n                            \n                            if st.button(\"üìÅ Create All Missing Folders\"):\n                                created_count = 0\n                                for missing in missing_folders:\n                                    folder_path = Path(missing['Path'])\n                                    folder_path.mkdir(parents=True, exist_ok=True)\n                                    created_count += 1\n                                st.success(f\"Created {created_count} folders!\")\n                                st.rerun()\n                    \n                    # Large attachment warnings\n                    large_attachments = [m for m in folder_mapping if m['Files'] > 0 and float(m['Size (MB)']) > 10]\n                    if large_attachments:\n                        with st.expander(f\"‚ö†Ô∏è Large Attachments ({len(large_attachments)})\"):\n                            st.warning(\"The following recipients have attachments over 10 MB:\")\n                            for large in large_attachments[:5]:\n                                st.write(f\"- **{large['Recipient']}**: {large['Size (MB)']} MB ({large['Files']} files)\")\n                            if len(large_attachments) > 5:\n                                st.write(f\"... and {len(large_attachments) - 5} more\")\n    \n    # Individual attachments info (legacy)\n    st.divider()\n    st.subheader(\"Excel Column Attachments (Optional)\")\n    st.markdown(\"You can also specify individual attachments in your Excel file using columns like `Attachment1`, `Attachment2`, etc.\")\n    \n    if st.session_state.excel_data is not None:\n        attachment_cols = [col for col in st.session_state.excel_data.columns if col.lower().startswith('attachment')]\n        if attachment_cols:\n            st.info(f\"Found attachment columns in Excel: {', '.join(attachment_cols)}\")\n        else:\n            st.info(\"No attachment columns found in Excel data\")\n    \n    # Navigation\n    st.divider()\n    col1, col2, col3 = st.columns([1, 1, 1])\n    with col1:\n        if st.button(\"‚óÄÔ∏è Back: Variable Mapping\"):\n            st.session_state.current_step = 3\n            st.rerun()\n    with col3:\n        if st.button(\"Next: Conditional Content ‚ñ∂Ô∏è\"):\n            st.session_state.current_step = 5\n            st.rerun()\n\ndef step_5_conditional_content():\n    st.header(\"5. Conditional Content Configuration\")\n    st.markdown(\"Configure conditional content that appears based on flags in your Excel data\")\n    \n    # JSON editor for conditional lines\n    st.subheader(\"Conditional Content Rules\")\n    st.markdown(\"Define text snippets that will be included when the corresponding Excel column is set to `1`\")\n    \n    # Load existing conditional lines\n    try:\n        with open('conditional_lines.json', 'r', encoding='utf-8') as f:\n            default_conditional = json.load(f)\n    except:\n        default_conditional = st.session_state.conditional_lines\n    \n    # JSON input\n    conditional_json = st.text_area(\n        \"Conditional Lines (JSON format)\",\n        value=json.dumps(default_conditional, indent=2),\n        height=200,\n        help=\"Define key-value pairs where the key matches an Excel column and the value is the text to include\"\n    )\n    \n    try:\n        conditional_data = json.loads(conditional_json)\n        st.session_state.conditional_lines = conditional_data\n        \n        # Show preview of conditional rules\n        if conditional_data:\n            st.success(\"‚úÖ JSON is valid\")\n            \n            col1, col2 = st.columns(2)\n            with col1:\n                st.subheader(\"Conditional Rules\")\n                for key, value in conditional_data.items():\n                    st.markdown(f\"**{key}:**\")\n                    st.markdown(f\"> {value}\")\n                    st.divider()\n            \n            with col2:\n                st.subheader(\"Excel Column Check\")\n                if st.session_state.excel_data is not None:\n                    excel_cols = st.session_state.excel_data.columns.tolist()\n                    for key in conditional_data.keys():\n                        if key in excel_cols:\n                            st.success(f\"‚úÖ `{key}` - Found in Excel\")\n                        else:\n                            st.warning(f\"‚ö†Ô∏è `{key}` - Not found in Excel\")\n                else:\n                    st.info(\"Upload Excel data to verify columns\")\n        else:\n            st.info(\"No conditional rules defined\")\n            \n    except json.JSONDecodeError as e:\n        st.error(f\"‚ùå Invalid JSON: {str(e)}\")\n    \n    # Save conditional lines\n    col1, col2, col3 = st.columns([1, 1, 1])\n    with col2:\n        if st.button(\"üíæ Save Conditional Rules\"):\n            with open('conditional_lines.json', 'w', encoding='utf-8') as f:\n                json.dump(st.session_state.conditional_lines, f, indent=2)\n            st.success(\"Conditional rules saved!\")\n    \n    # Navigation\n    st.divider()\n    col1, col2, col3 = st.columns([1, 1, 1])\n    with col1:\n        if st.button(\"‚óÄÔ∏è Back: Attachments\"):\n            st.session_state.current_step = 4\n            st.rerun()\n    with col3:\n        if st.button(\"Next: Preview & Generate ‚ñ∂Ô∏è\"):\n            st.session_state.current_step = 6\n            st.rerun()\n\ndef step_6_preview_generate():\n    st.header(\"6. Preview & Generate Emails\")\n    st.markdown(\"Preview your emails and generate Outlook drafts\")\n    \n    if st.session_state.excel_data is None:\n        st.error(\"Please upload Excel data first\")\n        return\n    \n    # Email preview\n    st.subheader(\"Email Preview\")\n    \n    # Select row for preview\n    preview_row_idx = st.selectbox(\n        \"Select row to preview:\",\n        range(len(st.session_state.excel_data)),\n        format_func=lambda x: f\"Row {x+1}: {st.session_state.excel_data.iloc[x].get('FirstName', st.session_state.excel_data.iloc[x].get('Email', f'Row {x+1}'))}\"\n    )\n    \n    if preview_row_idx is not None:\n        row = st.session_state.excel_data.iloc[preview_row_idx]\n        \n        # Show email preview\n        col1, col2 = st.columns([2, 1])\n        \n        with col1:\n            # Generate preview\n            is_html_mode = st.session_state.template_mode == \"rich\"\n            preview_text = create_preview_email(\n                row, \n                st.session_state.template_text, \n                st.session_state.template_variables,\n                st.session_state.conditional_lines,\n                is_html=is_html_mode\n            )\n            \n            st.markdown(\"**Email Preview:**\")\n            if is_html_mode:\n                # Show HTML preview for rich text mode\n                st.markdown(\"*Rich Text Preview:*\")\n                preview_html = create_html_preview(preview_text)\n                st.components.v1.html(preview_html, height=300, scrolling=True)\n                \n                # Option to view raw HTML\n                with st.expander(\"View Raw HTML\"):\n                    st.code(preview_text, language=\"html\")\n            else:\n                # Show plain text preview\n                st.text_area(\"\", value=preview_text, height=300, disabled=True)\n        \n        with col2:\n            st.markdown(\"**Email Details:**\")\n            \n            # Email addresses\n            email_field = row.get('Email') or row.get('email') or row.get('To') or 'No email'\n            st.write(f\"**To:** {email_field}\")\n            \n            if 'CC' in row or 'cc' in row:\n                cc_field = row.get('CC') or row.get('cc')\n                st.write(f\"**CC:** {cc_field}\")\n            \n            if 'BCC' in row or 'bcc' in row:\n                bcc_field = row.get('BCC') or row.get('bcc')\n                st.write(f\"**BCC:** {bcc_field}\")\n            \n            subject_field = row.get('Subject') or 'No Subject'\n            st.write(f\"**Subject:** {subject_field}\")\n            \n            # Show active conditional flags\n            active_flags = []\n            for key in st.session_state.conditional_lines.keys():\n                if key in row and row[key] == 1:\n                    active_flags.append(key)\n            \n            if active_flags:\n                st.write(f\"**Active Flags:** {', '.join(active_flags)}\")\n            \n            # Attachments info\n            st.write(\"**Attachments:**\")\n            attachments_to_add = []\n            \n            if st.session_state.attachment_mode == \"global\":\n                # Global attachments mode\n                if st.session_state.attachments_dir:\n                    files = list(st.session_state.attachments_dir.glob(\"*\"))\n                    files = [f for f in files if f.is_file()]\n                    attachments_to_add = files\n                    st.write(f\"  ‚Ä¢ {len(files)} global files\")\n                    if files:\n                        with st.expander(\"View attachments\"):\n                            for f in files[:10]:\n                                size_mb = f.stat().st_size / (1024 * 1024)\n                                st.write(f\"  - {f.name} ({size_mb:.2f} MB)\")\n                            if len(files) > 10:\n                                st.write(f\"  ... and {len(files) - 10} more\")\n                else:\n                    st.write(\"  ‚Ä¢ No global attachments\")\n            else:\n                # Per-recipient attachments mode\n                if st.session_state.per_recipient_attachments_base and st.session_state.attachment_identifier_column:\n                    identifier_value = str(row.get(st.session_state.attachment_identifier_column, \"\")).strip()\n                    if identifier_value:\n                        clean_identifier = re.sub(r'[^\\w\\s-]', '', identifier_value).strip()\n                        if clean_identifier:\n                            recipient_folder = st.session_state.per_recipient_attachments_base / clean_identifier\n                            if recipient_folder.exists():\n                                files = [f for f in recipient_folder.glob(\"*\") if f.is_file()]\n                                attachments_to_add = files\n                                st.write(f\"  ‚Ä¢ {len(files)} files from {clean_identifier}/\")\n                                if files:\n                                    with st.expander(\"View attachments\"):\n                                        total_size_mb = 0\n                                        for f in files[:10]:\n                                            size_mb = f.stat().st_size / (1024 * 1024)\n                                            total_size_mb += size_mb\n                                            st.write(f\"  - {f.name} ({size_mb:.2f} MB)\")\n                                        if len(files) > 10:\n                                            st.write(f\"  ... and {len(files) - 10} more\")\n                                        st.write(f\"  **Total: {total_size_mb:.2f} MB**\")\n                                        if total_size_mb > 25:\n                                            st.warning(\"‚ö†Ô∏è Large total size!\")\n                            else:\n                                st.warning(f\"  ‚Ä¢ Folder not found: {clean_identifier}/\")\n                                # Check if global fallback exists\n                                if st.session_state.attachments_dir:\n                                    files = list(st.session_state.attachments_dir.glob(\"*\"))\n                                    files = [f for f in files if f.is_file()]\n                                    if files:\n                                        st.info(f\"  ‚Ä¢ Will use {len(files)} global files as fallback\")\n                        else:\n                            st.warning(\"  ‚Ä¢ Invalid folder identifier\")\n                else:\n                    st.warning(\"  ‚Ä¢ Per-recipient mode not configured\")\n    \n    # Generation settings\n    st.subheader(\"Generation Settings\")\n    \n    col1, col2 = st.columns(2)\n    \n    with col1:\n        use_outlook = st.checkbox(\n            \"Create Outlook Drafts\",\n            value=True,\n            help=\"Create actual drafts in Microsoft Outlook (requires pywin32)\"\n        )\n        \n        create_eml_backup = st.checkbox(\n            \"Create .eml Backup Files\", \n            value=True,\n            help=\"Create .eml files as backup\"\n        )\n    \n    with col2:\n        # Check Outlook availability\n        try:\n            import win32com.client\n            st.success(\"‚úÖ Outlook integration available\")\n            outlook_available = True\n        except ImportError:\n            st.error(\"‚ùå Outlook integration not available (install pywin32)\")\n            outlook_available = False\n            use_outlook = False\n    \n    # Generate emails\n    st.divider()\n    \n    if st.button(\"üöÄ Generate All Emails\", type=\"primary\"):\n        if not use_outlook and not create_eml_backup:\n            st.error(\"Please select at least one output option\")\n            return\n        \n        # Show progress\n        progress_bar = st.progress(0)\n        status_text = st.empty()\n        results_container = st.container()\n        \n        try:\n            # Prepare parameters\n            if st.session_state.template_mode == \"rich\":\n                # Save as HTML template for rich text mode\n                template_path = st.session_state.output_dir / \"temp_template.html\"\n                with open(template_path, 'w', encoding='utf-8') as f:\n                    f.write(st.session_state.template_html)\n            else:\n                template_path = st.session_state.output_dir / \"temp_template.txt\"\n                with open(template_path, 'w', encoding='utf-8') as f:\n                    f.write(st.session_state.template_text)\n            \n            excel_path = st.session_state.output_dir / \"temp_data.xlsx\"\n            st.session_state.excel_data.to_excel(excel_path, index=False)\n            \n            conditionals_path = \"conditional_lines.json\"\n            with open(conditionals_path, 'w', encoding='utf-8') as f:\n                json.dump(st.session_state.conditional_lines, f, indent=2)\n            \n            # Call the main function from email_file_generator\n            status_text.text(\"Generating emails...\")\n            \n            # Prepare attachment parameters based on mode\n            if st.session_state.attachment_mode == \"per_recipient\":\n                attachments_dir = str(st.session_state.attachments_dir) if st.session_state.attachments_dir else None\n                per_recipient_base = str(st.session_state.per_recipient_attachments_base) if st.session_state.per_recipient_attachments_base else None\n                identifier_column = st.session_state.attachment_identifier_column\n            else:\n                attachments_dir = str(st.session_state.attachments_dir) if st.session_state.attachments_dir else None\n                per_recipient_base = None\n                identifier_column = None\n            \n            result = efg.main(\n                template_path=str(template_path),\n                excel_path=str(excel_path),\n                attachments_dir=attachments_dir,\n                output_dir=str(st.session_state.output_dir),\n                conditionals_path=conditionals_path,\n                use_outlook=use_outlook and outlook_available,\n                create_eml_backup=create_eml_backup,\n                is_html_template=(st.session_state.template_mode == \"rich\"),\n                attachment_mode=st.session_state.attachment_mode,\n                per_recipient_base=per_recipient_base,\n                identifier_column=identifier_column\n            )\n            \n            progress_bar.progress(1.0)\n            status_text.text(\"‚úÖ Generation complete!\")\n            \n            with results_container:\n                # Check if result is a dictionary (new format) or boolean (old format)\n                if isinstance(result, dict):\n                    if result['success']:\n                        st.success(f\"Successfully generated emails for {result['success_count']} out of {result['total_count']} recipients\")\n                        \n                        if result['error_count'] > 0:\n                            st.warning(f\"‚ö†Ô∏è {result['error_count']} emails failed to generate. Check console for details.\")\n                        \n                        if result.get('outlook_drafts_created'):\n                            st.info(\"üìß Outlook drafts have been created in your Drafts folder\")\n                        \n                        if result.get('eml_files_created'):\n                            st.info(f\"üìÑ Backup .eml files saved to: {result.get('output_dir', st.session_state.output_dir)}\")\n                    else:\n                        st.error(f\"Failed to generate emails. {result.get('error_count', 0)} errors occurred.\")\n                else:\n                    # Fallback for old boolean return format\n                    if result:\n                        st.success(f\"Successfully generated emails for {len(st.session_state.excel_data)} recipients\")\n                    else:\n                        st.error(\"Failed to generate emails\")\n                    \n                    if use_outlook and outlook_available:\n                        st.info(\"üìß Outlook drafts have been created in your Drafts folder\")\n                    \n                    if create_eml_backup:\n                        st.info(f\"üìÑ Backup .eml files saved to: {st.session_state.output_dir}\")\n            \n            # Cleanup temp files\n            if template_path.exists():\n                template_path.unlink()\n            if excel_path.exists():\n                excel_path.unlink()\n                \n        except Exception as e:\n            progress_bar.progress(0)\n            status_text.text(\"‚ùå Generation failed\")\n            st.error(f\"Error during generation: {str(e)}\")\n    \n    # Navigation\n    st.divider()\n    col1, col2, col3 = st.columns([1, 1, 1])\n    with col1:\n        if st.button(\"‚óÄÔ∏è Back: Conditional Content\"):\n            st.session_state.current_step = 5\n            st.rerun()\n    with col3:\n        if st.button(\"üîÑ Start Over\"):\n            # Reset session state\n            for key in ['template_text', 'excel_data', 'template_variables', 'conditional_lines', 'attachments_dir']:\n                if key in st.session_state:\n                    del st.session_state[key]\n            st.session_state.current_step = 1\n            st.rerun()\n\nif __name__ == \"__main__\":\n    main()\n","size_bytes":60139},"recovery_utils.py":{"content":"\"\"\"\nRecovery and Diagnostic Utilities for Email Generator\nProvides auto-save, recovery, and diagnostic features.\n\"\"\"\n\nimport streamlit as st\nimport json\nimport pickle\nfrom pathlib import Path\nfrom datetime import datetime, timedelta\nfrom typing import Dict, Any, Optional\nimport pandas as pd\nimport shutil\nfrom error_handler import error_handler\n\n\nclass SessionRecovery:\n    \"\"\"Handles session auto-save and recovery.\"\"\"\n    \n    def __init__(self, save_dir: str = \"session_backups\"):\n        \"\"\"Initialize session recovery system.\"\"\"\n        self.save_dir = Path(save_dir)\n        self.save_dir.mkdir(exist_ok=True)\n        self.auto_save_file = self.save_dir / \"auto_save.json\"\n        self.last_save_time = None\n    \n    def should_auto_save(self, interval_minutes: int = 5) -> bool:\n        \"\"\"Check if it's time to auto-save.\"\"\"\n        if self.last_save_time is None:\n            return True\n        \n        elapsed = datetime.now() - self.last_save_time\n        return elapsed > timedelta(minutes=interval_minutes)\n    \n    def auto_save_session(self, session_state: Any) -> bool:\n        \"\"\"Auto-save critical session data.\"\"\"\n        try:\n            save_data = {\n                'timestamp': datetime.now().isoformat(),\n                'template_text': getattr(session_state, 'template_text', ''),\n                'template_mode': getattr(session_state, 'template_mode', 'plain'),\n                'template_html': getattr(session_state, 'template_html', ''),\n                'template_variables': getattr(session_state, 'template_variables', []),\n                'conditional_lines': getattr(session_state, 'conditional_lines', {}),\n                'attachment_mode': getattr(session_state, 'attachment_mode', 'global'),\n                'current_step': getattr(session_state, 'current_step', 1)\n            }\n            \n            # Save Excel data separately if exists\n            if hasattr(session_state, 'excel_data') and session_state.excel_data is not None:\n                excel_file = self.save_dir / \"auto_save_excel.csv\"\n                session_state.excel_data.to_csv(excel_file, index=False)\n                save_data['has_excel_data'] = True\n            else:\n                save_data['has_excel_data'] = False\n            \n            # Write JSON data\n            with open(self.auto_save_file, 'w', encoding='utf-8') as f:\n                json.dump(save_data, f, indent=2)\n            \n            self.last_save_time = datetime.now()\n            return True\n            \n        except Exception as e:\n            error_handler.log_error(e, \"Auto-save Session\")\n            return False\n    \n    def recover_session(self, session_state: Any) -> bool:\n        \"\"\"Recover session from auto-save.\"\"\"\n        try:\n            if not self.auto_save_file.exists():\n                return False\n            \n            # Check if save is recent (within 24 hours)\n            if self.auto_save_file.stat().st_mtime < (datetime.now().timestamp() - 86400):\n                return False\n            \n            with open(self.auto_save_file, 'r', encoding='utf-8') as f:\n                save_data = json.load(f)\n            \n            # Restore session data\n            session_state.template_text = save_data.get('template_text', '')\n            session_state.template_mode = save_data.get('template_mode', 'plain')\n            session_state.template_html = save_data.get('template_html', '')\n            session_state.template_variables = save_data.get('template_variables', [])\n            session_state.conditional_lines = save_data.get('conditional_lines', {})\n            session_state.attachment_mode = save_data.get('attachment_mode', 'global')\n            session_state.current_step = save_data.get('current_step', 1)\n            \n            # Restore Excel data if exists\n            if save_data.get('has_excel_data'):\n                excel_file = self.save_dir / \"auto_save_excel.csv\"\n                if excel_file.exists():\n                    session_state.excel_data = pd.read_csv(excel_file)\n            \n            return True\n            \n        except Exception as e:\n            error_handler.log_error(e, \"Session Recovery\")\n            return False\n    \n    def clear_auto_save(self):\n        \"\"\"Clear auto-save files.\"\"\"\n        try:\n            if self.auto_save_file.exists():\n                self.auto_save_file.unlink()\n            \n            excel_file = self.save_dir / \"auto_save_excel.csv\"\n            if excel_file.exists():\n                excel_file.unlink()\n            \n            return True\n        except Exception as e:\n            error_handler.log_error(e, \"Clear Auto-save\")\n            return False\n    \n    def export_session(self, session_state: Any) -> Optional[Path]:\n        \"\"\"Export current session to a file.\"\"\"\n        try:\n            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')\n            export_file = self.save_dir / f\"session_export_{timestamp}.json\"\n            \n            export_data = {\n                'timestamp': datetime.now().isoformat(),\n                'template_text': getattr(session_state, 'template_text', ''),\n                'template_mode': getattr(session_state, 'template_mode', 'plain'),\n                'template_html': getattr(session_state, 'template_html', ''),\n                'template_variables': getattr(session_state, 'template_variables', []),\n                'conditional_lines': getattr(session_state, 'conditional_lines', {}),\n                'attachment_mode': getattr(session_state, 'attachment_mode', 'global'),\n                'current_step': getattr(session_state, 'current_step', 1)\n            }\n            \n            with open(export_file, 'w', encoding='utf-8') as f:\n                json.dump(export_data, f, indent=2)\n            \n            return export_file\n            \n        except Exception as e:\n            error_handler.log_error(e, \"Export Session\")\n            return None\n    \n    def import_session(self, file_path: Path, session_state: Any) -> bool:\n        \"\"\"Import session from a file.\"\"\"\n        try:\n            with open(file_path, 'r', encoding='utf-8') as f:\n                import_data = json.load(f)\n            \n            # Restore session data\n            session_state.template_text = import_data.get('template_text', '')\n            session_state.template_mode = import_data.get('template_mode', 'plain')\n            session_state.template_html = import_data.get('template_html', '')\n            session_state.template_variables = import_data.get('template_variables', [])\n            session_state.conditional_lines = import_data.get('conditional_lines', {})\n            session_state.attachment_mode = import_data.get('attachment_mode', 'global')\n            session_state.current_step = import_data.get('current_step', 1)\n            \n            return True\n            \n        except Exception as e:\n            error_handler.log_error(e, \"Import Session\")\n            return False\n\n\nclass ApplicationDiagnostics:\n    \"\"\"Provides diagnostic tools for the application.\"\"\"\n    \n    @staticmethod\n    def check_system_requirements() -> Dict[str, Any]:\n        \"\"\"Check if system meets all requirements.\"\"\"\n        import platform\n        import sys\n        \n        requirements = {\n            'python_version': {\n                'required': '3.7+',\n                'current': sys.version,\n                'met': sys.version_info >= (3, 7)\n            },\n            'platform': {\n                'current': platform.platform(),\n                'is_windows': platform.system() == 'Windows'\n            },\n            'modules': {}\n        }\n        \n        # Check required modules\n        required_modules = [\n            'streamlit',\n            'pandas',\n            'openpyxl',\n            'streamlit_quill'\n        ]\n        \n        for module_name in required_modules:\n            try:\n                __import__(module_name)\n                requirements['modules'][module_name] = {'installed': True}\n            except ImportError:\n                requirements['modules'][module_name] = {'installed': False}\n        \n        # Check optional modules\n        optional_modules = ['win32com.client']\n        for module_name in optional_modules:\n            try:\n                __import__(module_name)\n                requirements['modules'][module_name] = {\n                    'installed': True,\n                    'optional': True\n                }\n            except ImportError:\n                requirements['modules'][module_name] = {\n                    'installed': False,\n                    'optional': True\n                }\n        \n        # Check disk space\n        try:\n            total, used, free = shutil.disk_usage(\"/\")\n            requirements['disk_space'] = {\n                'free_gb': free // (2**30),\n                'sufficient': free > (100 * 1024 * 1024)  # 100MB minimum\n            }\n        except Exception:\n            requirements['disk_space'] = {'error': 'Could not check disk space'}\n        \n        # Check directory permissions\n        directories = ['logs', 'backups', 'templates', 'generated_emails', 'email_queue']\n        requirements['directories'] = {}\n        \n        for dir_name in directories:\n            dir_path = Path(dir_name)\n            try:\n                dir_path.mkdir(exist_ok=True)\n                test_file = dir_path / '.test'\n                test_file.touch()\n                test_file.unlink()\n                requirements['directories'][dir_name] = {'writable': True}\n            except Exception:\n                requirements['directories'][dir_name] = {'writable': False}\n        \n        return requirements\n    \n    @staticmethod\n    def run_self_test() -> Dict[str, bool]:\n        \"\"\"Run self-test on all major components.\"\"\"\n        tests = {}\n        \n        # Test template parsing\n        try:\n            from email_file_generator import extract_variables\n            test_template = \"Hello [Name], welcome to [Company]!\"\n            vars = extract_variables(test_template)\n            tests['template_parsing'] = vars == ['Name', 'Company']\n        except Exception:\n            tests['template_parsing'] = False\n        \n        # Test Excel handling\n        try:\n            test_df = pd.DataFrame({\n                'Email': ['test@example.com'],\n                'Name': ['Test User']\n            })\n            tests['excel_handling'] = True\n        except Exception:\n            tests['excel_handling'] = False\n        \n        # Test file operations\n        try:\n            test_file = Path('test_file.tmp')\n            test_file.write_text('test')\n            content = test_file.read_text()\n            test_file.unlink()\n            tests['file_operations'] = content == 'test'\n        except Exception:\n            tests['file_operations'] = False\n        \n        # Test JSON operations\n        try:\n            test_data = {'test': 'data'}\n            json_str = json.dumps(test_data)\n            loaded = json.loads(json_str)\n            tests['json_operations'] = loaded == test_data\n        except Exception:\n            tests['json_operations'] = False\n        \n        # Test error logging\n        try:\n            error_handler.logger.info(\"Test log entry\")\n            tests['error_logging'] = True\n        except Exception:\n            tests['error_logging'] = False\n        \n        return tests\n    \n    @staticmethod\n    def get_performance_metrics() -> Dict[str, Any]:\n        \"\"\"Get current performance metrics.\"\"\"\n        import psutil\n        import os\n        \n        metrics = {}\n        \n        # Memory usage\n        try:\n            process = psutil.Process(os.getpid())\n            memory_info = process.memory_info()\n            metrics['memory'] = {\n                'rss_mb': memory_info.rss / (1024 * 1024),\n                'percent': process.memory_percent()\n            }\n        except Exception:\n            metrics['memory'] = {'error': 'Could not get memory info'}\n        \n        # CPU usage\n        try:\n            metrics['cpu'] = {\n                'percent': psutil.cpu_percent(interval=1)\n            }\n        except Exception:\n            metrics['cpu'] = {'error': 'Could not get CPU info'}\n        \n        # Session size estimate\n        try:\n            session_size = 0\n            if hasattr(st.session_state, 'excel_data') and st.session_state.excel_data is not None:\n                session_size += st.session_state.excel_data.memory_usage(deep=True).sum()\n            metrics['session_size_mb'] = session_size / (1024 * 1024)\n        except Exception:\n            metrics['session_size_mb'] = 0\n        \n        return metrics\n\n\ndef display_error_dashboard():\n    \"\"\"Display error dashboard in Streamlit.\"\"\"\n    st.subheader(\"üîç Error Dashboard\")\n    \n    # Recent errors\n    recent_errors = error_handler.get_recent_errors(5)\n    \n    if recent_errors:\n        st.warning(f\"Found {len(recent_errors)} recent errors\")\n        \n        for i, error in enumerate(recent_errors, 1):\n            with st.expander(f\"Error {i}: {error['context']} - {error['timestamp'][:19]}\"):\n                st.write(f\"**Severity:** {error['severity']}\")\n                st.write(f\"**Type:** {error['error_type']}\")\n                st.write(f\"**Message:** {error['user_message']}\")\n                \n                if error.get('recovery_suggestions'):\n                    st.write(\"**Recovery Suggestions:**\")\n                    for suggestion in error['recovery_suggestions']:\n                        st.write(f\"‚Ä¢ {suggestion}\")\n                \n                if st.button(f\"Copy Error Details\", key=f\"copy_error_{i}\"):\n                    error_text = json.dumps(error, indent=2)\n                    st.code(error_text, language='json')\n    else:\n        st.success(\"‚úÖ No recent errors\")\n    \n    # Actions\n    col1, col2 = st.columns(2)\n    with col1:\n        if st.button(\"Clear Error History\", use_container_width=True):\n            error_handler.clear_error_history()\n            st.success(\"Error history cleared\")\n            st.rerun()\n    \n    with col2:\n        if st.button(\"Export Error Report\", use_container_width=True):\n            report = error_handler.export_error_report()\n            st.download_button(\n                \"Download Report\",\n                report,\n                \"error_report.txt\",\n                \"text/plain\",\n                use_container_width=True\n            )\n\n\ndef display_diagnostic_panel():\n    \"\"\"Display diagnostic panel in Streamlit.\"\"\"\n    st.subheader(\"üõ†Ô∏è System Diagnostics\")\n    \n    diagnostics = ApplicationDiagnostics()\n    \n    # System requirements check\n    with st.expander(\"System Requirements\"):\n        requirements = diagnostics.check_system_requirements()\n        \n        # Python version\n        python_ok = requirements['python_version']['met']\n        if python_ok:\n            st.success(f\"‚úÖ Python {requirements['python_version']['required']} or higher\")\n        else:\n            st.error(f\"‚ùå Python {requirements['python_version']['required']} required\")\n        \n        # Modules\n        st.write(\"**Required Modules:**\")\n        for module, info in requirements['modules'].items():\n            if not info.get('optional', False):\n                if info['installed']:\n                    st.write(f\"‚úÖ {module}\")\n                else:\n                    st.write(f\"‚ùå {module} (not installed)\")\n        \n        # Disk space\n        if 'free_gb' in requirements.get('disk_space', {}):\n            free_gb = requirements['disk_space']['free_gb']\n            if requirements['disk_space']['sufficient']:\n                st.success(f\"‚úÖ Disk space: {free_gb}GB free\")\n            else:\n                st.error(f\"‚ùå Low disk space: {free_gb}GB free\")\n    \n    # Self-test\n    with st.expander(\"Component Self-Test\"):\n        if st.button(\"Run Self-Test\", use_container_width=True):\n            with st.spinner(\"Running tests...\"):\n                test_results = diagnostics.run_self_test()\n            \n            for test_name, passed in test_results.items():\n                if passed:\n                    st.success(f\"‚úÖ {test_name.replace('_', ' ').title()}\")\n                else:\n                    st.error(f\"‚ùå {test_name.replace('_', ' ').title()}\")\n    \n    # Performance metrics\n    with st.expander(\"Performance Metrics\"):\n        try:\n            metrics = diagnostics.get_performance_metrics()\n            \n            col1, col2, col3 = st.columns(3)\n            with col1:\n                if 'memory' in metrics and 'rss_mb' in metrics['memory']:\n                    st.metric(\"Memory Usage\", f\"{metrics['memory']['rss_mb']:.1f} MB\")\n            with col2:\n                if 'cpu' in metrics and 'percent' in metrics['cpu']:\n                    st.metric(\"CPU Usage\", f\"{metrics['cpu']['percent']}%\")\n            with col3:\n                if 'session_size_mb' in metrics:\n                    st.metric(\"Session Size\", f\"{metrics['session_size_mb']:.1f} MB\")\n        except ImportError:\n            st.info(\"Install psutil for performance metrics: pip install psutil\")\n\n\n# Global session recovery instance\nsession_recovery = SessionRecovery()","size_bytes":17179},"create_project_zip.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nCreate a zip file of the email generator project for local testing.\nExcludes runtime-generated directories and temporary files.\n\"\"\"\n\nimport zipfile\nimport os\nfrom pathlib import Path\n\ndef should_exclude(file_path):\n    \"\"\"Check if a file/directory should be excluded from the zip.\"\"\"\n    exclude_dirs = {\n        'logs', 'backups', 'session_backups', 'generated_emails', \n        'email_queue', 'test_rich_text_output', '__pycache__', '.git'\n    }\n    exclude_files = {\n        'uv.lock', '.gitignore', 'create_project_zip.py'\n    }\n    exclude_extensions = {'.pyc', '.pyo', '.log'}\n    \n    path = Path(file_path)\n    \n    # Check if any parent directory is in exclude_dirs\n    for part in path.parts:\n        if part in exclude_dirs:\n            return True\n    \n    # Check if filename is in exclude_files\n    if path.name in exclude_files:\n        return True\n    \n    # Check if file extension should be excluded\n    if path.suffix in exclude_extensions:\n        return True\n    \n    return False\n\ndef create_project_zip():\n    \"\"\"Create a zip file of the project.\"\"\"\n    zip_filename = 'email_generator_project.zip'\n    \n    with zipfile.ZipFile(zip_filename, 'w', zipfile.ZIP_DEFLATED) as zipf:\n        # Walk through all files and directories\n        for root, dirs, files in os.walk('.'):\n            # Remove excluded directories from dirs list to prevent walking into them\n            dirs[:] = [d for d in dirs if not should_exclude(os.path.join(root, d))]\n            \n            for file in files:\n                file_path = os.path.join(root, file)\n                \n                # Skip excluded files\n                if should_exclude(file_path):\n                    continue\n                \n                # Add file to zip\n                # Use relative path and remove leading './'\n                arc_name = file_path[2:] if file_path.startswith('./') else file_path\n                zipf.write(file_path, arc_name)\n                print(f\"Added: {arc_name}\")\n    \n    # Get zip file size\n    zip_size = os.path.getsize(zip_filename) / (1024 * 1024)  # MB\n    print(f\"\\n‚úÖ Created {zip_filename} ({zip_size:.1f} MB)\")\n    print(f\"üì¶ Contains project files for local testing\")\n    print(f\"\\nTo use locally:\")\n    print(f\"1. Extract the zip file\")\n    print(f\"2. Install dependencies: pip install -r requirements.txt (or use pyproject.toml)\")\n    print(f\"3. Run the app: streamlit run app.py --server.port 5000\")\n\nif __name__ == \"__main__\":\n    create_project_zip()","size_bytes":2518},"email_file_generator.py":{"content":"import os\nimport re\nimport mimetypes\nfrom email.message import EmailMessage\nimport pandas as pd\nimport json\ntry:\n    import win32com.client\n    OUTLOOK_AVAILABLE = True\nexcept ImportError:\n    OUTLOOK_AVAILABLE = False\n    print(\"Warning: win32com not available. Install with: pip install pywin32\")\n\n\ndef extract_variables(template_text):\n    \"\"\"Return a list of variables like ['FirstName', 'Company'] found in the template.\"\"\"\n    return re.findall(r\"\\[([^\\]]+)\\]\", template_text)\n\n\ndef apply_text_formatting(text):\n    \"\"\"Apply text formatting like bold, italic, etc.\"\"\"\n    if not text:\n        return text\n    \n    # Convert markdown-style formatting to HTML\n    # **text** -> <b>text</b> (bold)\n    text = re.sub(r'\\*\\*(.*?)\\*\\*', r'<b>\\1</b>', text)\n    # *text* -> <i>text</i> (italic)\n    text = re.sub(r'\\*(.*?)\\*', r'<i>\\1</i>', text)\n    # __text__ -> <u>text</u> (underline)\n    text = re.sub(r'__(.*?)__', r'<u>\\1</u>', text)\n    \n    return text\n\n\ndef convert_to_html_email(text):\n    \"\"\"Convert plain text to HTML format for email.\"\"\"\n    if not text:\n        return text\n    \n    # Apply text formatting first\n    text = apply_text_formatting(text)\n    \n    # Convert line breaks to HTML\n    text = text.replace('\\n', '<br>')\n    \n    # Wrap in basic HTML structure\n    html_body = f\"\"\"<html>\n<head>\n<meta charset=\"UTF-8\">\n</head>\n<body style=\"font-family: Arial, sans-serif; font-size: 11pt;\">\n{text}\n</body>\n</html>\"\"\"\n    \n    return html_body\n\n\ndef clean_email_encoding(text):\n    \"\"\"Clean up email encoding artifacts like quoted-printable characters.\"\"\"\n    if not text:\n        return text\n    \n    # Remove quoted-printable encoding artifacts\n    text = text.replace('=\\n', '')  # Remove soft line breaks\n    text = text.replace('=\\r\\n', '')  # Remove soft line breaks (Windows)\n    text = text.replace('=\\r', '')  # Remove soft line breaks (Mac)\n    \n    # Common quoted-printable encoded characters\n    replacements = {\n        '=20': ' ',    # space\n        '=3D': '=',    # equals sign\n        '=0A': '\\n',   # newline\n        '=0D': '\\r',   # carriage return\n        '=22': '\"',    # double quote\n        '=27': \"'\",    # single quote\n        '=2C': ',',    # comma\n        '=3B': ';',    # semicolon\n        '=3A': ':',    # colon\n        '=2E': '.',    # period\n        '=2D': '-',    # hyphen\n        '=5F': '_',    # underscore\n        '=40': '@',    # at symbol\n        '=24': '$',    # dollar sign\n        '=25': '%',    # percent sign\n        '=26': '&',    # ampersand\n        '=2B': '+',    # plus sign\n        '=3C': '<',    # less than\n        '=3E': '>',    # greater than\n        '=3F': '?',    # question mark\n        '=21': '!',    # exclamation mark\n        '=28': '(',    # left parenthesis\n        '=29': ')',    # right parenthesis\n        '=5B': '[',    # left bracket\n        '=5D': ']',    # right bracket\n        '=7B': '{',    # left brace\n        '=7D': '}',    # right brace\n        '=7C': '|',    # pipe\n        '=5C': '\\\\',   # backslash\n        '=2F': '/',    # forward slash\n        '=7E': '~',    # tilde\n    }\n    \n    for encoded, decoded in replacements.items():\n        text = text.replace(encoded, decoded)\n    \n    # Remove any remaining stray = characters that might be encoding artifacts\n    # But be careful not to remove legitimate = signs in content\n    # Only remove = that appear at line breaks or followed by unusual characters\n    text = re.sub(r'=(?=\\s|$)', '', text)  # Remove = at end of lines or before whitespace\n    \n    return text\n\n\ndef fill_template(template_text, row, variables):\n    \"\"\"Fill template placeholders with row values, leaving placeholders if missing.\"\"\"\n    result = template_text\n    for var in variables:\n        if var in row and pd.notna(row[var]):\n            value = str(row[var])\n            # Clean encoding artifacts from the value\n            value = clean_email_encoding(value)\n            result = result.replace(f\"[{var}]\", value)\n    \n    # Clean the final result as well\n    result = clean_email_encoding(result)\n    return result\n\n\ndef parse_email_addresses(email_str):\n    \"\"\"\n    Parse comma-separated email addresses and return a list.\n    Ignores any addresses enclosed in square brackets, e.g., [test@example.com],\n    which can be used as a manual circuit breaker to temporarily disable a recipient.\n    \"\"\"\n    if not email_str or pd.isna(email_str):\n        return []\n    \n    # Split by comma, strip whitespace, and filter out bracketed or empty emails\n    emails = [\n        email.strip() \n        for email in str(email_str).split(',') \n        if email.strip() and not (email.strip().startswith('[') and email.strip().endswith(']'))\n    ]\n    return emails\n\n\ndef create_email_message(row, template_text, variables, attachments_dir, attachment_columns, conditional_lines, is_html_template=False, attachment_mode=\"global\", per_recipient_base=None, identifier_column=None):\n    \"\"\"Create EmailMessage object for a DataFrame row as a clean email (no draft prefixes).\n    \n    Args:\n        row: DataFrame row with recipient data\n        template_text: Email template text\n        variables: List of template variables\n        attachments_dir: Global attachments directory (used in global mode)\n        attachment_columns: Columns containing individual attachment filenames\n        conditional_lines: Dictionary of conditional content\n        is_html_template: Whether the template is HTML\n        attachment_mode: \"global\" or \"per_recipient\"\n        per_recipient_base: Base folder for per-recipient attachments\n        identifier_column: Column to use for per-recipient folder names\n    \"\"\"\n    msg = EmailMessage()\n\n    # Handle To addresses (clean, no [DRAFT] prefix)\n    to_addresses = parse_email_addresses(row.get('Email') or row.get('email') or row.get('To'))\n    if to_addresses:\n        msg['To'] = ', '.join(to_addresses)\n    \n    # Handle CC addresses (clean, no [DRAFT] prefix)\n    cc_addresses = parse_email_addresses(row.get('CC') or row.get('cc'))\n    # Add default CC address - removing the hardcoded bracket for Streamlit version\n    # default_cc = '['  # Always CC this address\n    # if default_cc:\n    #     cc_addresses.append(default_cc)\n    if cc_addresses:\n        msg['CC'] = ', '.join(cc_addresses)\n    \n    # Handle BCC addresses (clean, no [DRAFT] prefix)\n    bcc_addresses = parse_email_addresses(row.get('BCC') or row.get('bcc'))\n    if bcc_addresses:\n        msg['BCC'] = ', '.join(bcc_addresses)\n    \n    msg['From'] = row.get('From') or 'sender@example.com'\n    msg['Subject'] = row.get('Subject') or 'No Subject'  # Clean subject, no [DRAFT] prefix\n    \n    # Add some email headers for better compatibility\n    msg['X-Draft-Info'] = 'Generated email - Review before sending'\n\n    # First, fill in the main template placeholders\n    body = fill_template(template_text, row, variables)\n\n    # Second, handle conditional placeholders\n    conditional_placeholders = re.findall(r\"\\[Conditional:([^\\]]+)\\]\", body)\n    for placeholder_key in conditional_placeholders:\n        placeholder_tag = f\"[Conditional:{placeholder_key}]\"\n        replacement_text = \"\" # Default to empty string\n        # Check if the flag is set to 1 in the Excel row\n        if placeholder_key in conditional_lines and placeholder_key in row and row[placeholder_key] == 1:\n            # If so, get the text from the JSON and fill its own placeholders\n            raw_text = conditional_lines[placeholder_key]\n            replacement_text = fill_template(raw_text, row, variables)\n        \n        body = body.replace(placeholder_tag, replacement_text)\n\n    # Set clean email body without draft notices\n    # Support both plain text and HTML\n    if is_html_template:\n        # Template is already HTML, use it directly\n        # Create a plain text version from HTML\n        plain_text = re.sub(r'<[^>]+>', '', body)  # Simple HTML tag removal\n        plain_text = plain_text.replace('&nbsp;', ' ').replace('&lt;', '<').replace('&gt;', '>').replace('&amp;', '&')\n        plain_text = plain_text.replace('&quot;', '\"').replace('&#39;', \"'\")  # Additional entity replacements\n        # Set plain text first, then add HTML alternative\n        msg.set_content(plain_text)\n        msg.add_alternative(body, subtype='html')\n    else:\n        # Convert plain text to HTML\n        html_body = convert_to_html_email(body)\n        msg.set_content(body)  # Plain text version\n        msg.add_alternative(html_body, subtype='html')  # HTML version\n\n    # Determine which attachments directory to use\n    actual_attachments_dir = attachments_dir\n    attachment_source = \"global\"\n    \n    if attachment_mode == \"per_recipient\" and per_recipient_base and identifier_column:\n        # Get the identifier value for this recipient\n        identifier_value = str(row.get(identifier_column, \"\")).strip()\n        if identifier_value:\n            # Clean identifier for folder name (remove special characters)\n            clean_identifier = re.sub(r'[^\\w\\s-]', '', identifier_value).strip()\n            if clean_identifier:\n                per_recipient_dir = os.path.join(per_recipient_base, clean_identifier)\n                if os.path.exists(per_recipient_dir):\n                    actual_attachments_dir = per_recipient_dir\n                    attachment_source = f\"per-recipient ({clean_identifier})\"\n                    print(f\"  üìÅ Using per-recipient folder: {clean_identifier}\")\n                else:\n                    print(f\"  ‚ö†Ô∏è Per-recipient folder not found: {clean_identifier}, falling back to global attachments\")\n    \n    # Attach files from the determined directory\n    total_size_mb = 0\n    attached_files = []\n    \n    if actual_attachments_dir and os.path.exists(actual_attachments_dir):\n        for filename in os.listdir(actual_attachments_dir):\n            file_path = os.path.join(actual_attachments_dir, filename)\n            # Only attach files (not directories)\n            if os.path.isfile(file_path):\n                try:\n                    file_size_mb = os.path.getsize(file_path) / (1024 * 1024)\n                    \n                    # Warn about large files\n                    if file_size_mb > 10:\n                        print(f\"  ‚ö†Ô∏è Large attachment: {filename} ({file_size_mb:.2f} MB)\")\n                    \n                    with open(file_path, 'rb') as fh:\n                        data = fh.read()\n                    ctype, _ = mimetypes.guess_type(file_path)\n                    if ctype:\n                        maintype, subtype = ctype.split('/', 1)\n                    else:\n                        maintype, subtype = 'application', 'octet-stream'\n                    msg.add_attachment(data, maintype=maintype, subtype=subtype, filename=filename)\n                    attached_files.append(filename)\n                    total_size_mb += file_size_mb\n                    print(f\"  ‚úÖ Attached: {filename} ({file_size_mb:.2f} MB) from {attachment_source}\")\n                except Exception as e:\n                    print(f\"  ‚ùå Failed to attach {filename}: {e}\")\n    \n    if total_size_mb > 25:\n        print(f\"  ‚ö†Ô∏è Warning: Total attachment size is {total_size_mb:.2f} MB - may exceed email limits\")\n    \n    # Legacy: Also handle attachment columns if specified (for backward compatibility)\n    for col in attachment_columns:\n        filename = row.get(col)\n        if filename and pd.notna(filename):\n            # Extract just the filename if it's a full path\n            filename_str = str(filename).strip().strip('\"\\'')  # Remove quotes and whitespace\n            base_filename = os.path.basename(filename_str)  # Extract just the filename part\n            file_path = os.path.join(attachments_dir, base_filename)\n            try:\n                with open(file_path, 'rb') as fh:\n                    data = fh.read()\n                ctype, _ = mimetypes.guess_type(file_path)\n                if ctype:\n                    maintype, subtype = ctype.split('/', 1)\n                else:\n                    maintype, subtype = 'application', 'octet-stream'\n                msg.add_attachment(data, maintype=maintype, subtype=subtype, filename=base_filename)\n                attached_files.append(base_filename)\n                print(f\"  ‚úÖ Attached from Excel: {base_filename}\")\n            except FileNotFoundError:\n                print(f\"  ‚ùå Attachment not found: {file_path} (original: {base_filename})\")\n            except Exception as e:\n                print(f\"  ‚ùå Failed to attach from Excel {base_filename}: {e}\")\n    \n    # Return msg with attachment info for tracking\n    return msg\n\n\ndef create_outlook_draft(row, template_text, variables, attachments_dir, attachment_columns, conditional_lines, is_html_template=False, attachment_mode=\"global\", per_recipient_base=None, identifier_column=None):\n    \"\"\"Create an actual Outlook draft from the row data.\n    \n    Args:\n        row: DataFrame row with recipient data\n        template_text: Email template text\n        variables: List of template variables\n        attachments_dir: Global attachments directory (used in global mode)\n        attachment_columns: Columns containing individual attachment filenames\n        conditional_lines: Dictionary of conditional content\n        is_html_template: Whether the template is HTML\n        attachment_mode: \"global\" or \"per_recipient\"\n        per_recipient_base: Base folder for per-recipient attachments\n        identifier_column: Column to use for per-recipient folder names\n    \"\"\"\n    if not OUTLOOK_AVAILABLE:\n        raise ImportError(\"win32com.client not available. Install with: pip install pywin32\")\n    \n    try:\n        print(\"  üìß Connecting to Outlook...\", end=\"\", flush=True)\n        outlook = win32com.client.Dispatch(\"Outlook.Application\")\n        print(\" ‚úÖ\")\n        \n        print(\"  üìù Creating email item...\", end=\"\", flush=True)\n        mail = outlook.CreateItem(0)  # 0 = Mail item\n        print(\" ‚úÖ\")\n        \n        # Handle To addresses (original addresses without [DRAFT] prefix for Outlook)\n        to_addresses = parse_email_addresses(row.get('Email') or row.get('email') or row.get('To'))\n        if to_addresses:\n            mail.To = '; '.join(to_addresses)\n        \n        # Handle CC addresses\n        cc_addresses = parse_email_addresses(row.get('CC') or row.get('cc'))\n        # Remove default CC bracket for Streamlit version\n        # default_cc = '['  # Always CC this address\n        # if default_cc:\n        #     cc_addresses.append(default_cc)\n        if cc_addresses:\n            mail.CC = '; '.join(cc_addresses)\n        \n        # Handle BCC addresses\n        bcc_addresses = parse_email_addresses(row.get('BCC') or row.get('bcc'))\n        if bcc_addresses:\n            mail.BCC = '; '.join(bcc_addresses)\n        \n        # Set sender if specified\n        sender = row.get('From')\n        if sender:\n            try:\n                mail.SentOnBehalfOfName = sender\n            except Exception:\n                print(f\"    ‚ö†Ô∏è Could not set sender to {sender}\")\n        \n        # Set subject (clean, no [DRAFT] prefix since this is already a draft in Outlook)\n        subject = row.get('Subject') or 'No Subject'\n        mail.Subject = subject\n        \n        print(\"  üìÑ Processing email body...\", end=\"\", flush=True)\n        # Process email body\n        body = fill_template(template_text, row, variables)\n        \n        # Handle conditional placeholders\n        conditional_placeholders = re.findall(r\"\\[Conditional:([^\\]]+)\\]\", body)\n        for placeholder_key in conditional_placeholders:\n            placeholder_tag = f\"[Conditional:{placeholder_key}]\"\n            replacement_text = \"\"\n            if placeholder_key in conditional_lines and placeholder_key in row and row[placeholder_key] == 1:\n                raw_text = conditional_lines[placeholder_key]\n                replacement_text = fill_template(raw_text, row, variables)\n            body = body.replace(placeholder_tag, replacement_text)\n        \n        # Set clean email body without draft notices\n        if is_html_template:\n            # Template is already HTML\n            mail.HTMLBody = body\n            # Create plain text version\n            plain_text = re.sub(r'<[^>]+>', '', body)\n            plain_text = plain_text.replace('&nbsp;', ' ').replace('&lt;', '<').replace('&gt;', '>').replace('&amp;', '&')\n            mail.Body = plain_text\n        else:\n            # Convert plain text to HTML\n            mail.Body = body\n            mail.HTMLBody = convert_to_html_email(body)\n        print(\" ‚úÖ\")\n        \n        # Add attachments\n        print(\"  üìé Adding attachments...\", end=\"\", flush=True)\n        attachment_count = 0\n        attachment_debug = []\n        \n        # Determine which attachments directory to use\n        actual_attachments_dir = attachments_dir\n        attachment_source = \"global\"\n        \n        if attachment_mode == \"per_recipient\" and per_recipient_base and identifier_column:\n            # Get the identifier value for this recipient\n            identifier_value = str(row.get(identifier_column, \"\")).strip()\n            if identifier_value:\n                # Clean identifier for folder name (remove special characters)\n                clean_identifier = re.sub(r'[^\\w\\s-]', '', identifier_value).strip()\n                if clean_identifier:\n                    per_recipient_dir = os.path.join(per_recipient_base, clean_identifier)\n                    if os.path.exists(per_recipient_dir):\n                        actual_attachments_dir = per_recipient_dir\n                        attachment_source = f\"per-recipient ({clean_identifier})\"\n                        attachment_debug.append(f\"Using per-recipient folder: {clean_identifier}\")\n                    else:\n                        attachment_debug.append(f\"Per-recipient folder not found: {clean_identifier}, using global\")\n        \n        # Attach files from the determined directory\n        total_size_mb = 0\n        if actual_attachments_dir and os.path.exists(actual_attachments_dir):\n            for filename in os.listdir(actual_attachments_dir):\n                file_path = os.path.join(actual_attachments_dir, filename)\n                # Only attach files (not directories)\n                if os.path.isfile(file_path):\n                    file_size_mb = os.path.getsize(file_path) / (1024 * 1024)\n                    attachment_debug.append(f\"Trying to attach: {file_path} ({file_size_mb:.2f} MB) from {attachment_source}\")\n                    \n                    # Warn about large files\n                    if file_size_mb > 10:\n                        attachment_debug.append(f\"‚ö†Ô∏è Large attachment: {filename} ({file_size_mb:.2f} MB)\")\n                    \n                    try:\n                        mail.Attachments.Add(file_path)\n                        attachment_count += 1\n                        total_size_mb += file_size_mb\n                        attachment_debug.append(f\"‚úÖ Successfully attached: {filename}\")\n                    except Exception as e:\n                        attachment_debug.append(f\"‚ùå Failed to attach {filename}: {e}\")\n        \n        if total_size_mb > 25:\n            attachment_debug.append(f\"‚ö†Ô∏è Warning: Total attachment size is {total_size_mb:.2f} MB\")\n        \n        # Legacy: Also handle attachment columns if specified (for backward compatibility)\n        for col in attachment_columns:\n            filename = row.get(col)\n            if filename and pd.notna(filename):\n                filename_str = str(filename).strip().strip('\"\\'')\n                base_filename = os.path.basename(filename_str)\n                file_path = os.path.join(attachments_dir, base_filename) if attachments_dir else base_filename\n                attachment_debug.append(f\"Trying to attach from Excel: {file_path}\")\n                try:\n                    mail.Attachments.Add(file_path)\n                    attachment_count += 1\n                    attachment_debug.append(f\"‚úÖ Successfully attached from Excel: {base_filename}\")\n                except Exception as e:\n                    attachment_debug.append(f\"‚ùå Failed to attach from Excel {base_filename}: {e}\")\n        \n        print(f\" ‚úÖ ({attachment_count} files)\")\n        \n        # Save as draft (don't send)\n        print(\"  üíæ Saving as draft...\", end=\"\", flush=True)\n        mail.Save()\n        print(\" ‚úÖ\")\n        \n        print(f\"  üéØ Draft created successfully!\")\n        \n        # Return debug info for troubleshooting\n        return {\n            'success': True,\n            'attachment_count': attachment_count,\n            'debug_info': attachment_debug\n        }\n        \n    except Exception as e:\n        print(f\" ‚ùå Error: {e}\")\n        return {\n            'success': False,\n            'error': str(e),\n            'debug_info': attachment_debug if 'attachment_debug' in locals() else []\n        }\n\n\ndef sanitize_filename(filename):\n    \"\"\"Convert a string to a safe filename by removing/replacing problematic characters.\"\"\"\n    # Replace problematic characters with underscores\n    sanitized = re.sub(r'[<>:\"/\\\\|?*]', '_', filename)\n    # Remove any remaining control characters\n    sanitized = ''.join(char for char in sanitized if ord(char) >= 32)\n    # Limit length and strip whitespace\n    sanitized = sanitized.strip()[:100]\n    return sanitized if sanitized else \"email\"\n\n\ndef main(template_path, excel_path, attachments_dir=None, output_dir=\"generated_emails\", \n         conditionals_path=\"conditional_lines.json\", use_outlook=True, create_eml_backup=True, is_html_template=False,\n         attachment_mode=\"global\", per_recipient_base=None, identifier_column=None):\n    \"\"\"\n    Main function to generate emails from template and Excel data.\n    \n    Args:\n        template_path: Path to email template file\n        excel_path: Path to Excel file with recipient data\n        attachments_dir: Path to directory containing attachments (optional)\n        output_dir: Directory to save .eml files (optional)\n        conditionals_path: Path to conditional lines JSON file (optional)\n        use_outlook: Whether to create Outlook drafts (requires pywin32)\n        create_eml_backup: Whether to create .eml backup files\n        is_html_template: Whether the template is HTML\n        attachment_mode: \"global\" or \"per_recipient\"\n        per_recipient_base: Base folder for per-recipient attachments\n        identifier_column: Column to use for per-recipient folder names\n    \n    Returns:\n        dict: Result dictionary with success status, counts, and any warnings/errors\n    \"\"\"\n    \n    # Load template\n    print(f\"üìñ Loading template from: {template_path}\")\n    try:\n        with open(template_path, 'r', encoding='utf-8') as f:\n            template_text = f.read()\n        print(\"‚úÖ Template loaded\")\n        # Log if this is an HTML template\n        if is_html_template:\n            print(\"üìù Template format: HTML\")\n        else:\n            print(\"üìù Template format: Plain text\")\n    except Exception as e:\n        print(f\"‚ùå Error loading template: {e}\")\n        return False\n    \n    # Extract variables from template\n    variables = extract_variables(template_text)\n    print(f\"üîç Found variables: {variables}\")\n    \n    # Load Excel data\n    print(f\"üìä Loading Excel data from: {excel_path}\")\n    try:\n        df = pd.read_excel(excel_path)\n        print(f\"‚úÖ Loaded {len(df)} rows\")\n    except Exception as e:\n        print(f\"‚ùå Error loading Excel: {e}\")\n        return False\n    \n    # Load conditional lines if they exist\n    conditional_lines = {}\n    if conditionals_path and os.path.exists(conditionals_path):\n        try:\n            with open(conditionals_path, 'r', encoding='utf-8') as f:\n                conditional_lines = json.load(f)\n            print(f\"üîÄ Loaded {len(conditional_lines)} conditional lines\")\n        except Exception as e:\n            print(f\"‚ö†Ô∏è Warning: Could not load conditional lines: {e}\")\n    \n    # Create output directory\n    if create_eml_backup:\n        os.makedirs(output_dir, exist_ok=True)\n        print(f\"üìÅ Output directory: {output_dir}\")\n    \n    # Find attachment columns\n    attachment_columns = [col for col in df.columns if col.lower().startswith('attachment')]\n    if attachment_columns:\n        print(f\"üìé Found attachment columns: {attachment_columns}\")\n    \n    # Check Outlook availability\n    if use_outlook:\n        if OUTLOOK_AVAILABLE:\n            print(\"üîó Outlook integration available\")\n        else:\n            print(\"‚ö†Ô∏è Outlook integration not available - falling back to .eml files only\")\n            use_outlook = False\n            create_eml_backup = True\n    \n    # Log attachment mode\n    if attachment_mode == \"per_recipient\":\n        print(f\"üìÇ Attachment mode: Per-recipient\")\n        print(f\"   Base folder: {per_recipient_base}\")\n        print(f\"   Identifier column: {identifier_column}\")\n    else:\n        print(f\"üìÇ Attachment mode: Global\")\n        if attachments_dir:\n            print(f\"   Attachments folder: {attachments_dir}\")\n    \n    # Process each row\n    success_count = 0\n    error_count = 0\n    \n    print(f\"\\nüöÄ Processing {len(df)} emails...\")\n    \n    for idx, row in df.iterrows():\n        print(f\"\\nüìß Processing row {idx + 1}/{len(df)}\")\n        \n        # Get recipient name for filename\n        recipient_name = row.get('FirstName') or row.get('Email') or row.get('email') or f\"row_{idx}\"\n        print(f\"  üë§ Recipient: {recipient_name}\")\n        \n        try:\n            # Create Outlook draft if requested\n            outlook_success = True\n            if use_outlook:\n                result = create_outlook_draft(\n                    row, template_text, variables, attachments_dir, attachment_columns, conditional_lines, \n                    is_html_template, attachment_mode, per_recipient_base, identifier_column\n                )\n                outlook_success = result['success']\n                if not outlook_success:\n                    print(f\"  ‚ö†Ô∏è Outlook draft failed: {result.get('error', 'Unknown error')}\")\n            \n            # Create .eml backup if requested\n            eml_success = True\n            if create_eml_backup:\n                # Create email message\n                msg = create_email_message(\n                    row, template_text, variables, attachments_dir, attachment_columns, conditional_lines, \n                    is_html_template, attachment_mode, per_recipient_base, identifier_column\n                )\n                \n                # Generate filename\n                subject = row.get('Subject') or 'No Subject'\n                safe_subject = sanitize_filename(subject)\n                filename = f\"{sanitize_filename(recipient_name)}_{safe_subject}.eml\"\n                filepath = os.path.join(output_dir, filename)\n                \n                # Save .eml file\n                with open(filepath, 'w', encoding='utf-8') as f:\n                    f.write(str(msg))\n                print(f\"  üíæ Saved: {filename}\")\n            \n            if outlook_success or eml_success:\n                success_count += 1\n            else:\n                error_count += 1\n                \n        except Exception as e:\n            print(f\"  ‚ùå Error processing row {idx + 1}: {e}\")\n            error_count += 1\n    \n    # Summary\n    print(f\"\\nüìä Summary:\")\n    print(f\"‚úÖ Successful: {success_count}\")\n    print(f\"‚ùå Failed: {error_count}\")\n    print(f\"üìß Total processed: {len(df)}\")\n    \n    if use_outlook and success_count > 0:\n        print(f\"üéØ Check your Outlook Drafts folder for {success_count} draft emails\")\n    \n    if create_eml_backup and success_count > 0:\n        print(f\"üìÅ Backup .eml files saved to: {output_dir}\")\n    \n    # Return detailed result dictionary\n    return {\n        'success': success_count > 0,\n        'success_count': success_count,\n        'error_count': error_count,\n        'total_count': len(df),\n        'outlook_drafts_created': use_outlook and success_count > 0,\n        'eml_files_created': create_eml_backup and success_count > 0,\n        'output_dir': output_dir if create_eml_backup else None\n    }\n\n\nif __name__ == \"__main__\":\n    # Default configuration - modify as needed\n    result = main(\n        template_path=\"email_template.txt\",\n        excel_path=\"recipients.xlsx\",\n        attachments_dir=\"attachments\",\n        output_dir=\"generated_emails\",\n        conditionals_path=\"conditional_lines.json\",\n        use_outlook=True,\n        create_eml_backup=True\n    )\n    \n    if result:\n        print(\"\\nüéâ Email generation completed successfully!\")\n    else:\n        print(\"\\nüí• Email generation failed!\")\n","size_bytes":28665},"ATTACHMENT_FIXES_REPORT.md":{"content":"# Attachment Management Implementation Fixes - Report\n\n## Summary\nAll requested issues in the bulk attachment management implementation have been successfully fixed and tested.\n\n## Fixes Completed\n\n### 1. Fixed Parameter Passing in app.py Step 6 ‚úÖ\n**Location:** `app.py` lines 1174-1198\n\n**Changes Made:**\n- The attachment parameters are now properly passed to `efg.main()`:\n  - `attachment_mode` (global or per_recipient)\n  - `per_recipient_base` (base folder for per-recipient attachments)\n  - `identifier_column` (column used to identify recipient folders)\n- The code correctly handles both Global and Per-Recipient modes with appropriate fallback logic\n\n**Code Snippet:**\n```python\n# Lines 1174-1183 in app.py\nif st.session_state.attachment_mode == \"per_recipient\":\n    attachments_dir = str(st.session_state.attachments_dir) if st.session_state.attachments_dir else None\n    per_recipient_base = str(st.session_state.per_recipient_attachments_base) if st.session_state.per_recipient_attachments_base else None\n    identifier_column = st.session_state.attachment_identifier_column\nelse:\n    attachments_dir = str(st.session_state.attachments_dir) if st.session_state.attachments_dir else None\n    per_recipient_base = None\n    identifier_column = None\n```\n\n### 2. Fixed Attachment Loop in create_email_message Function ‚úÖ\n**Location:** `email_file_generator.py` lines 261-299\n\n**Issues Fixed:**\n- Removed malformed else block (lines 262-265 were improperly structured)\n- Fixed undefined `base_filename` reference in error messages (line 295)\n- Added proper exception handling for attachment operations\n- Ensured MIME type handling is correct with fallback to 'application/octet-stream'\n\n**Key Changes:**\n- Fixed the MIME type detection logic to properly handle unknown file types\n- Added `attached_files` list to track successful attachments\n- Improved error messages to use the correct variable names\n- Added comprehensive exception handling for both directory and Excel-specified attachments\n\n### 3. Enhanced Warning/Error Capture for UI Display ‚úÖ\n**Location:** `email_file_generator.py` lines 493-658 and `app.py` lines 1204-1231\n\n**Improvements Made:**\n- Modified `main()` function to return a detailed result dictionary instead of just a boolean\n- Result dictionary includes:\n  - `success`: boolean indicating overall success\n  - `success_count`: number of successfully generated emails\n  - `error_count`: number of failed emails\n  - `total_count`: total number of recipients processed\n  - `outlook_drafts_created`: whether Outlook drafts were created\n  - `eml_files_created`: whether .eml backup files were created\n  - `output_dir`: directory where files were saved\n- Updated app.py to handle the new result format and display appropriate UI messages\n\n**UI Enhancement:**\n```python\n# Lines 1206-1219 in app.py\nif isinstance(result, dict):\n    if result['success']:\n        st.success(f\"Successfully generated emails for {result['success_count']} out of {result['total_count']} recipients\")\n        \n        if result['error_count'] > 0:\n            st.warning(f\"‚ö†Ô∏è {result['error_count']} emails failed to generate. Check console for details.\")\n        \n        if result.get('outlook_drafts_created'):\n            st.info(\"üìß Outlook drafts have been created in your Drafts folder\")\n        \n        if result.get('eml_files_created'):\n            st.info(f\"üìÑ Backup .eml files saved to: {result.get('output_dir', st.session_state.output_dir)}\")\n```\n\n### 4. Tested Both Attachment Modes ‚úÖ\n**Test Script:** `test_attachment_modes.py`\n\n**Test Results:**\n- **Global Attachment Mode:** ‚úÖ PASSED\n  - All recipients received the same global attachments\n  - Successfully attached files from the global attachments directory\n  \n- **Per-Recipient Attachment Mode:** ‚úÖ PASSED\n  - Recipients with dedicated folders received their specific attachments\n  - Recipients without folders correctly fell back to global attachments\n  - Proper warnings were displayed for missing folders\n\n**Test Coverage:**\n- Created test data with 3 recipients\n- Alice: Has per-recipient folder with specific attachments\n- Bob: Has per-recipient folder with different attachments\n- Charlie: No per-recipient folder (tests fallback to global)\n- All scenarios worked correctly\n\n## Backward Compatibility\nAll fixes maintain complete backward compatibility:\n- The main() function still accepts boolean returns for legacy compatibility\n- Existing functionality remains unchanged\n- New features are additive and don't break existing code\n\n## Files Modified\n1. `email_file_generator.py` - Fixed attachment handling and improved error reporting\n2. `app.py` - Enhanced UI status display and proper parameter passing\n3. `test_attachment_modes.py` - Created comprehensive test suite\n\n## Verification\nThe implementation has been verified through:\n1. Unit testing with the test script\n2. Manual testing in the Streamlit UI\n3. Code review to ensure all issues were addressed\n\n## Conclusion\nAll requested issues have been successfully resolved:\n- ‚úÖ Attachment parameters are properly passed in Step 6\n- ‚úÖ Attachment loop errors fixed in create_email_message\n- ‚úÖ Warning/error capture improved for UI display\n- ‚úÖ Both attachment modes tested and working correctly\n- ‚úÖ Backward compatibility maintained\n\nThe bulk attachment management feature is now fully functional and robust.","size_bytes":5367},"attached_assets/README_1757692481628.md":{"content":"# autoemlbuilder\n\nThis repository contains a simple tool for generating `.eml` email files from a text template and an Excel spreadsheet of recipients.\n\n## Usage\n1. Prepare the following files and folders in the project directory:\n   - `email_template.txt` ‚Äì email body template with placeholders such as `[FirstName]`.\n   - `recipients.xlsx` ‚Äì spreadsheet with columns matching the placeholders. An `Email` column is required. Optional columns may include `Attachment1`, `Attachment2`, etc.\n   - `attachments/` ‚Äì folder containing any files referenced in the spreadsheet.\n   - `generated_emails/` ‚Äì (created automatically) where `.eml` files will be saved.\n   - `conditional_lines.json` ‚Äì (optional) a JSON file defining lines to be added to the email body based on Excel columns.\n\n### Excel columns\n\nThe spreadsheet can contain the following columns:\n\n| Column name        | Required | Description                                                                                   |\n|--------------------|----------|-----------------------------------------------------------------------------------------------|\n| `Email` or `To`    | Yes      | Primary recipient address(es). Use comma-separated values for multiple recipients.            |\n| `CC`               | No       | Carbon copy recipient address(es). Use comma-separated values for multiple recipients.        |\n| `BCC`              | No       | Blind carbon copy recipient address(es). Use comma-separated values for multiple recipients.  |\n| `From`             | No       | Sender address. Defaults to `sender@example.com` if omitted.                                   |\n| `Subject`          | No       | Email subject. Defaults to `No Subject`.                                                       |\n| `FirstName`        | No       | Used to build the output file name and available as a template variable.                      |\n| `Attachment*`      | No       | Any columns beginning with `Attachment` are treated as filenames to attach to the message.     |\n| Other placeholders | No       | Additional columns with names matching placeholders in `email_template.txt` (e.g. `LastName`). |\n| *Custom flags*     | No       | Columns matching keys in `conditional_lines.json`. Set the value to `1` to include the line. |\n\n### Conditional Content\n\nYou can add specific lines to the email body based on flags in your Excel file. This is useful for including optional paragraphs, like a special offer or a meeting reminder.\n\n1.  **Create `conditional_lines.json`:**\n    In your project directory, create a file named `conditional_lines.json`. This file contains a dictionary where each key is a column name you'll use in Excel, and the value is the line of text to add.\n\n    **Example `conditional_lines.json`:**\n    ```json\n    {\n      \"SpecialOffer\": \"As a valued customer, we would like to offer you a special discount of [Discount]%.\",\n      \"MeetingReminder\": \"This is a friendly reminder about our meeting scheduled for [MeetingDate].\"\n    }\n    ```\n\n2.  **Add Flags to Excel:**\n    In your `recipients.xlsx` file, add columns with names that exactly match the keys from your JSON file (e.g., `SpecialOffer`). To include the conditional line for a specific recipient, set the cell value to `1`.\n\n    **Example Excel data:**\n    | Email | FirstName | SpecialOffer | MeetingReminder | Discount | MeetingDate |\n    |-------|-----------|--------------|-----------------|----------|-------------|\n    | john@example.com | John | 1 | 0 | 15 | 2025-07-15 |\n    | jane@example.com | Jane | 0 | 1 | | 2025-07-18 |\n    | alice@company.com| Alice | 1 | 1 | 20 | 2025-07-20 |\n\n3.  **Result:**\n    - **John's email** will include the \"SpecialOffer\" line with the discount filled in.\n    - **Jane's email** will include the \"MeetingReminder\" line.\n    - **Alice's email** will include both lines.\n\nThe script will automatically detect `conditional_lines.json` and process these flags.\n\n#### Controlling Position (Granular)\n\nTo place each conditional line in a specific location within your email, use placeholders in the format `[Conditional:Key]` inside your `email_template.txt`. The `Key` must exactly match a key from your `conditional_lines.json` file.\n\n**Example `email_template.txt`:**\n```\nHi [FirstName],\n\n[Conditional:SpecialOffer]\n\nWe are looking forward to our meeting.\n[Conditional:MeetingReminder]\n\nThank you,\nThe Team\n```\n\n**How it Works:**\n- The script finds all `[Conditional:Key]` placeholders in the template.\n- For each placeholder, it checks the corresponding column (`Key`) in the Excel file for that recipient.\n- If the column's value is `1`, the placeholder is replaced with the text from `conditional_lines.json`.\n- If the column's value is not `1` (or is empty), the placeholder is removed, leaving no empty space.\n\nThis method gives you precise control over the placement of each piece of conditional content.\n\n### Multiple Recipients\n\nYou can send emails to multiple recipients by using comma-separated email addresses in the `Email` (or `To`), `CC`, and `BCC` columns:\n\n**Example Excel data:**\n| Email | CC | BCC | Subject | FirstName |\n|-------|----|----|---------|-----------|\n| john@example.com, jane@example.com | manager@example.com | hr@example.com | Welcome | John |\n| alice@company.com | bob@company.com, charlie@company.com | | Meeting | Alice |\n\nThis will create emails with:\n- **To**: Multiple primary recipients\n- **CC**: Carbon copy recipients (visible to all)\n- **BCC**: Blind carbon copy recipients (hidden from other recipients)\n\n#### Manual Circuit Breaker\n\nTo quickly and temporarily disable an email address in the `To`, `CC`, or `BCC` fields without deleting it, you can wrap it in square brackets. The script will ignore any address formatted like `[user@example.com]`.\n\nAdditionally, a single open bracket `[` is appended by default to the end of the `CC` line in every generated email. This is a deliberate feature to act as a manual \"circuit breaker.\" Most email clients will see this as an invalid address, preventing the email from being sent until a user manually reviews and removes the bracket. This helps prevent accidental bulk sending.\n\n2. Run the generator:\n\n```bash\npython email_file_generator.py\n```\n\nAdjust the paths by editing the `main()` call at the bottom of `email_file_generator.py` or by modifying the default arguments.\n\nThe script prints progress information and produces one `.eml` file for each row in the spreadsheet.\n","size_bytes":6459},"error_handler.py":{"content":"\"\"\"\nCentralized Error Handling and Logging System\nProvides robust error handling, logging, and recovery utilities for the Email Generator app.\n\"\"\"\n\nimport logging\nimport traceback\nimport json\nimport os\nfrom pathlib import Path\nfrom datetime import datetime, timedelta\nfrom typing import Dict, List, Optional, Any, Tuple\nimport streamlit as st\nfrom functools import wraps\nimport shutil\nimport pandas as pd\n\n\nclass ErrorHandler:\n    \"\"\"Centralized error handling and logging system.\"\"\"\n    \n    def __init__(self, log_dir: str = \"logs\", max_log_size: int = 10 * 1024 * 1024):\n        \"\"\"\n        Initialize the error handler.\n        \n        Args:\n            log_dir: Directory for log files\n            max_log_size: Maximum log file size before rotation (default 10MB)\n        \"\"\"\n        self.log_dir = Path(log_dir)\n        self.log_dir.mkdir(exist_ok=True)\n        \n        self.log_file = self.log_dir / \"app.log\"\n        self.error_log_file = self.log_dir / \"errors.json\"\n        self.max_log_size = max_log_size\n        \n        # Initialize logging\n        self._setup_logging()\n        \n        # Initialize error history\n        self.error_history = self._load_error_history()\n        \n        # Initialize backup directory\n        self.backup_dir = Path(\"backups\")\n        self.backup_dir.mkdir(exist_ok=True)\n    \n    def _setup_logging(self):\n        \"\"\"Setup logging configuration.\"\"\"\n        # Create formatter\n        formatter = logging.Formatter(\n            '%(asctime)s - %(name)s - %(levelname)s - %(message)s',\n            datefmt='%Y-%m-%d %H:%M:%S'\n        )\n        \n        # Setup file handler with rotation\n        if self.log_file.exists() and self.log_file.stat().st_size > self.max_log_size:\n            # Rotate log file\n            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')\n            rotated_file = self.log_dir / f\"app_{timestamp}.log\"\n            self.log_file.rename(rotated_file)\n            \n            # Keep only last 5 rotated logs\n            self._cleanup_old_logs()\n        \n        # Create file handler\n        file_handler = logging.FileHandler(self.log_file, encoding='utf-8')\n        file_handler.setFormatter(formatter)\n        \n        # Setup logger\n        self.logger = logging.getLogger('EmailGenerator')\n        self.logger.setLevel(logging.DEBUG)\n        self.logger.addHandler(file_handler)\n        \n        # Also log to console in debug mode\n        if os.environ.get('DEBUG'):\n            console_handler = logging.StreamHandler()\n            console_handler.setFormatter(formatter)\n            self.logger.addHandler(console_handler)\n    \n    def _cleanup_old_logs(self):\n        \"\"\"Keep only the 5 most recent rotated log files.\"\"\"\n        log_files = sorted(\n            [f for f in self.log_dir.glob(\"app_*.log\")],\n            key=lambda x: x.stat().st_mtime,\n            reverse=True\n        )\n        \n        # Delete old log files\n        for old_log in log_files[5:]:\n            try:\n                old_log.unlink()\n            except Exception:\n                pass\n    \n    def _load_error_history(self) -> List[Dict]:\n        \"\"\"Load error history from JSON file.\"\"\"\n        if self.error_log_file.exists():\n            try:\n                with open(self.error_log_file, 'r', encoding='utf-8') as f:\n                    return json.load(f)\n            except Exception:\n                return []\n        return []\n    \n    def _save_error_history(self):\n        \"\"\"Save error history to JSON file.\"\"\"\n        try:\n            # Keep only last 100 errors\n            self.error_history = self.error_history[-100:]\n            \n            with open(self.error_log_file, 'w', encoding='utf-8') as f:\n                json.dump(self.error_history, f, indent=2)\n        except Exception as e:\n            self.logger.error(f\"Failed to save error history: {str(e)}\")\n    \n    def log_error(self, error: Exception, context: str = \"\", user_message: str = \"\", \n                  severity: str = \"ERROR\") -> Dict:\n        \"\"\"\n        Log an error with context and user-friendly message.\n        \n        Args:\n            error: The exception that occurred\n            context: Context where the error occurred\n            user_message: User-friendly error message\n            severity: ERROR, WARNING, or CRITICAL\n        \n        Returns:\n            Error record dictionary\n        \"\"\"\n        error_record = {\n            \"timestamp\": datetime.now().isoformat(),\n            \"severity\": severity,\n            \"context\": context,\n            \"error_type\": type(error).__name__,\n            \"error_message\": str(error),\n            \"user_message\": user_message or self._get_user_friendly_message(error, context),\n            \"traceback\": traceback.format_exc() if severity == \"CRITICAL\" else \"\",\n            \"recovery_suggestions\": self._get_recovery_suggestions(error, context)\n        }\n        \n        # Log to file\n        self.logger.log(\n            getattr(logging, severity),\n            f\"{context}: {error_record['error_message']}\"\n        )\n        \n        # Add to error history\n        self.error_history.append(error_record)\n        self._save_error_history()\n        \n        return error_record\n    \n    def _get_user_friendly_message(self, error: Exception, context: str) -> str:\n        \"\"\"Generate user-friendly error message based on error type and context.\"\"\"\n        error_messages = {\n            \"FileNotFoundError\": \"The specified file could not be found. Please check the file path.\",\n            \"PermissionError\": \"Permission denied. Please check file permissions or try running as administrator.\",\n            \"pd.errors.EmptyDataError\": \"The Excel file appears to be empty. Please check the file contents.\",\n            \"KeyError\": \"Required data column is missing. Please check your Excel file structure.\",\n            \"ValueError\": \"Invalid data format detected. Please check your input data.\",\n            \"json.JSONDecodeError\": \"Invalid JSON format. Please check the configuration file.\",\n            \"ConnectionError\": \"Connection failed. Please check your network connection.\",\n            \"TimeoutError\": \"Operation timed out. Please try again.\",\n            \"MemoryError\": \"Not enough memory to complete the operation. Try processing fewer items.\",\n            \"OSError\": \"System error occurred. Please check disk space and file permissions.\"\n        }\n        \n        # Context-specific messages\n        if \"Excel\" in context or \"excel\" in context:\n            if isinstance(error, (pd.errors.EmptyDataError, KeyError)):\n                return \"Excel file validation failed. Please ensure the file contains the required columns (Email, Subject) and is not empty.\"\n            elif isinstance(error, FileNotFoundError):\n                return \"Excel file not found. Please upload a valid Excel file.\"\n        \n        if \"Template\" in context or \"template\" in context:\n            if isinstance(error, ValueError):\n                return \"Template parsing error. Please check for matching brackets [] in your template.\"\n            elif isinstance(error, FileNotFoundError):\n                return \"Template file not found. Please create or upload a template.\"\n        \n        if \"Attachment\" in context or \"attachment\" in context:\n            if isinstance(error, FileNotFoundError):\n                return \"One or more attachment files could not be found. Please check the attachment directory.\"\n            elif isinstance(error, PermissionError):\n                return \"Cannot access attachment files. Please check file permissions.\"\n        \n        if \"Outlook\" in context:\n            return \"Outlook integration error. Please ensure Outlook is installed and running.\"\n        \n        # Default messages by error type\n        error_type = type(error).__name__\n        return error_messages.get(error_type, f\"An unexpected error occurred: {str(error)}\")\n    \n    def _get_recovery_suggestions(self, error: Exception, context: str) -> List[str]:\n        \"\"\"Get recovery suggestions based on error type and context.\"\"\"\n        suggestions = []\n        \n        if isinstance(error, FileNotFoundError):\n            suggestions.extend([\n                \"Verify the file path is correct\",\n                \"Check if the file was moved or deleted\",\n                \"Try uploading the file again\"\n            ])\n        \n        elif isinstance(error, PermissionError):\n            suggestions.extend([\n                \"Check file permissions\",\n                \"Close the file if it's open in another application\",\n                \"Try saving to a different location\"\n            ])\n        \n        elif isinstance(error, (pd.errors.EmptyDataError, KeyError)):\n            suggestions.extend([\n                \"Ensure the Excel file has the required columns\",\n                \"Check that the file is not empty\",\n                \"Verify column names match the template variables\"\n            ])\n        \n        elif isinstance(error, ValueError):\n            if \"template\" in context.lower():\n                suggestions.extend([\n                    \"Check for matching brackets [] in the template\",\n                    \"Ensure all placeholders are properly closed\",\n                    \"Try using the template validator\"\n                ])\n            else:\n                suggestions.extend([\n                    \"Check the data format\",\n                    \"Ensure numeric fields contain valid numbers\",\n                    \"Verify date formats are correct\"\n                ])\n        \n        elif isinstance(error, MemoryError):\n            suggestions.extend([\n                \"Try processing fewer emails at once\",\n                \"Close other applications to free up memory\",\n                \"Restart the application\"\n            ])\n        \n        # Add general suggestions\n        suggestions.extend([\n            \"Check the error log for more details\",\n            \"Try restoring from a recent backup\",\n            \"Reset the application if the issue persists\"\n        ])\n        \n        return suggestions[:5]  # Return top 5 suggestions\n    \n    def create_backup(self, data: Any, backup_name: str, backup_type: str = \"json\") -> Optional[Path]:\n        \"\"\"\n        Create a backup of data.\n        \n        Args:\n            data: Data to backup\n            backup_name: Name for the backup\n            backup_type: Type of backup (json, csv, text)\n        \n        Returns:\n            Path to backup file or None if failed\n        \"\"\"\n        try:\n            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')\n            backup_file = self.backup_dir / f\"{backup_name}_{timestamp}.{backup_type}\"\n            \n            if backup_type == \"json\":\n                with open(backup_file, 'w', encoding='utf-8') as f:\n                    json.dump(data, f, indent=2)\n            elif backup_type == \"csv\" and isinstance(data, pd.DataFrame):\n                data.to_csv(backup_file, index=False)\n            elif backup_type == \"text\":\n                with open(backup_file, 'w', encoding='utf-8') as f:\n                    f.write(str(data))\n            else:\n                # Copy file\n                if isinstance(data, (str, Path)):\n                    shutil.copy2(data, backup_file)\n            \n            self.logger.info(f\"Created backup: {backup_file}\")\n            \n            # Clean up old backups (keep last 10)\n            self._cleanup_old_backups(backup_name)\n            \n            return backup_file\n            \n        except Exception as e:\n            self.logger.error(f\"Failed to create backup: {str(e)}\")\n            return None\n    \n    def _cleanup_old_backups(self, backup_name: str):\n        \"\"\"Keep only the 10 most recent backups for a given name.\"\"\"\n        backup_files = sorted(\n            [f for f in self.backup_dir.glob(f\"{backup_name}_*\")],\n            key=lambda x: x.stat().st_mtime,\n            reverse=True\n        )\n        \n        for old_backup in backup_files[10:]:\n            try:\n                old_backup.unlink()\n            except Exception:\n                pass\n    \n    def restore_backup(self, backup_file: Path) -> Tuple[bool, Any]:\n        \"\"\"\n        Restore data from a backup file.\n        \n        Args:\n            backup_file: Path to backup file\n        \n        Returns:\n            Tuple of (success, data or error message)\n        \"\"\"\n        try:\n            if not backup_file.exists():\n                return False, \"Backup file not found\"\n            \n            ext = backup_file.suffix.lower()\n            \n            if ext == \".json\":\n                with open(backup_file, 'r', encoding='utf-8') as f:\n                    data = json.load(f)\n            elif ext == \".csv\":\n                data = pd.read_csv(backup_file)\n            elif ext in [\".txt\", \".html\"]:\n                with open(backup_file, 'r', encoding='utf-8') as f:\n                    data = f.read()\n            else:\n                return False, f\"Unsupported backup format: {ext}\"\n            \n            self.logger.info(f\"Restored backup from: {backup_file}\")\n            return True, data\n            \n        except Exception as e:\n            error_msg = f\"Failed to restore backup: {str(e)}\"\n            self.logger.error(error_msg)\n            return False, error_msg\n    \n    def get_recent_errors(self, limit: int = 10) -> List[Dict]:\n        \"\"\"Get recent errors from history.\"\"\"\n        return self.error_history[-limit:]\n    \n    def clear_error_history(self):\n        \"\"\"Clear error history.\"\"\"\n        self.error_history = []\n        self._save_error_history()\n        self.logger.info(\"Error history cleared\")\n    \n    def export_error_report(self) -> str:\n        \"\"\"Export error report as formatted text.\"\"\"\n        report = [\"=\" * 80]\n        report.append(\"EMAIL GENERATOR ERROR REPORT\")\n        report.append(f\"Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\")\n        report.append(\"=\" * 80)\n        report.append(\"\")\n        \n        if not self.error_history:\n            report.append(\"No errors recorded.\")\n        else:\n            for i, error in enumerate(self.error_history[-20:], 1):\n                report.append(f\"Error #{i}\")\n                report.append(\"-\" * 40)\n                report.append(f\"Time: {error['timestamp']}\")\n                report.append(f\"Severity: {error['severity']}\")\n                report.append(f\"Context: {error['context']}\")\n                report.append(f\"Error: {error['error_message']}\")\n                report.append(f\"User Message: {error['user_message']}\")\n                \n                if error.get('recovery_suggestions'):\n                    report.append(\"Recovery Suggestions:\")\n                    for suggestion in error['recovery_suggestions']:\n                        report.append(f\"  - {suggestion}\")\n                \n                if error.get('traceback'):\n                    report.append(\"Traceback:\")\n                    report.append(error['traceback'])\n                \n                report.append(\"\")\n        \n        return \"\\n\".join(report)\n\n\nclass SafeOperation:\n    \"\"\"Decorator for safe operation execution with error handling.\"\"\"\n    \n    def __init__(self, error_handler: ErrorHandler, context: str, \n                 show_user_message: bool = True, create_backup: bool = False):\n        \"\"\"\n        Initialize safe operation decorator.\n        \n        Args:\n            error_handler: ErrorHandler instance\n            context: Context for error logging\n            show_user_message: Whether to show error message to user\n            create_backup: Whether to create backup before operation\n        \"\"\"\n        self.error_handler = error_handler\n        self.context = context\n        self.show_user_message = show_user_message\n        self.create_backup = create_backup\n    \n    def __call__(self, func):\n        @wraps(func)\n        def wrapper(*args, **kwargs):\n            try:\n                # Create backup if requested\n                if self.create_backup and 'backup_data' in kwargs:\n                    backup_data = kwargs.pop('backup_data')\n                    backup_name = kwargs.pop('backup_name', self.context)\n                    self.error_handler.create_backup(backup_data, backup_name)\n                \n                # Execute function\n                result = func(*args, **kwargs)\n                return result\n                \n            except Exception as e:\n                # Log error\n                error_record = self.error_handler.log_error(\n                    e, \n                    context=self.context,\n                    severity=\"ERROR\" if not isinstance(e, (MemoryError, OSError)) else \"CRITICAL\"\n                )\n                \n                # Show user message if in Streamlit context\n                if self.show_user_message and 'streamlit' in str(type(st)):\n                    st.error(f\"‚ùå {error_record['user_message']}\")\n                    \n                    # Show recovery suggestions\n                    if error_record.get('recovery_suggestions'):\n                        with st.expander(\"üí° Recovery Suggestions\"):\n                            for suggestion in error_record['recovery_suggestions']:\n                                st.write(f\"‚Ä¢ {suggestion}\")\n                \n                # Re-raise or return None based on severity\n                if error_record['severity'] == \"CRITICAL\":\n                    raise\n                return None\n        \n        return wrapper\n\n\n# Global error handler instance\nerror_handler = ErrorHandler()\n\n\ndef validate_email_address(email: str) -> Tuple[bool, str]:\n    \"\"\"\n    Validate email address format.\n    \n    Args:\n        email: Email address to validate\n    \n    Returns:\n        Tuple of (is_valid, error_message)\n    \"\"\"\n    import re\n    \n    if not email or not email.strip():\n        return False, \"Email address is empty\"\n    \n    # Basic email regex pattern\n    email_pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$'\n    \n    # Handle multiple emails (comma-separated)\n    emails = [e.strip() for e in email.split(',')]\n    invalid_emails = []\n    \n    for single_email in emails:\n        # Skip bracketed emails (manual circuit breaker)\n        if single_email.startswith('[') and single_email.endswith(']'):\n            continue\n        \n        if not re.match(email_pattern, single_email):\n            invalid_emails.append(single_email)\n    \n    if invalid_emails:\n        return False, f\"Invalid email format: {', '.join(invalid_emails)}\"\n    \n    return True, \"\"\n\n\ndef validate_file_size(file_path: Path, max_size_mb: float = 25) -> Tuple[bool, str]:\n    \"\"\"\n    Validate file size.\n    \n    Args:\n        file_path: Path to file\n        max_size_mb: Maximum allowed size in MB\n    \n    Returns:\n        Tuple of (is_valid, error_message)\n    \"\"\"\n    try:\n        if not file_path.exists():\n            return False, f\"File not found: {file_path}\"\n        \n        file_size_mb = file_path.stat().st_size / (1024 * 1024)\n        \n        if file_size_mb > max_size_mb:\n            return False, f\"File too large: {file_size_mb:.2f}MB (max: {max_size_mb}MB)\"\n        \n        return True, \"\"\n        \n    except Exception as e:\n        return False, f\"Error checking file size: {str(e)}\"\n\n\ndef validate_template_syntax(template_text: str) -> Tuple[bool, List[str]]:\n    \"\"\"\n    Validate template syntax for proper bracket matching.\n    \n    Args:\n        template_text: Template text to validate\n    \n    Returns:\n        Tuple of (is_valid, list of errors)\n    \"\"\"\n    errors = []\n    \n    # Check for unclosed brackets\n    open_brackets = template_text.count('[')\n    close_brackets = template_text.count(']')\n    \n    if open_brackets != close_brackets:\n        errors.append(f\"Mismatched brackets: {open_brackets} opening, {close_brackets} closing\")\n    \n    # Check for empty placeholders\n    if '[]' in template_text:\n        errors.append(\"Empty placeholder [] found\")\n    \n    # Check for nested placeholders\n    import re\n    placeholders = re.findall(r'\\[([^\\]]*\\[.*?\\].*?)\\]', template_text)\n    if placeholders:\n        errors.append(f\"Nested placeholders found: {placeholders}\")\n    \n    # Check for special characters in placeholders\n    all_placeholders = re.findall(r'\\[([^\\]]+)\\]', template_text)\n    for placeholder in all_placeholders:\n        if not placeholder.replace(':', '').replace('_', '').replace(' ', '').isalnum():\n            if not placeholder.startswith('Conditional:'):\n                errors.append(f\"Invalid characters in placeholder: [{placeholder}]\")\n    \n    return len(errors) == 0, errors\n\n\ndef create_diagnostic_report() -> Dict[str, Any]:\n    \"\"\"Create a diagnostic report of the system state.\"\"\"\n    import platform\n    import sys\n    \n    report = {\n        \"timestamp\": datetime.now().isoformat(),\n        \"system\": {\n            \"platform\": platform.platform(),\n            \"python_version\": sys.version,\n            \"streamlit_version\": st.__version__ if 'st' in globals() else \"Unknown\"\n        },\n        \"directories\": {},\n        \"disk_space\": {},\n        \"recent_errors\": []\n    }\n    \n    # Check directories\n    for dir_name in [\"logs\", \"backups\", \"templates\", \"generated_emails\", \"email_queue\"]:\n        dir_path = Path(dir_name)\n        report[\"directories\"][dir_name] = {\n            \"exists\": dir_path.exists(),\n            \"writable\": os.access(dir_path, os.W_OK) if dir_path.exists() else False\n        }\n    \n    # Check disk space\n    try:\n        import shutil\n        total, used, free = shutil.disk_usage(\"/\")\n        report[\"disk_space\"] = {\n            \"total_gb\": total // (2**30),\n            \"used_gb\": used // (2**30),\n            \"free_gb\": free // (2**30),\n            \"percentage_used\": (used / total) * 100\n        }\n    except Exception:\n        report[\"disk_space\"] = {\"error\": \"Could not determine disk space\"}\n    \n    # Get recent errors\n    if 'error_handler' in globals():\n        report[\"recent_errors\"] = error_handler.get_recent_errors(5)\n    \n    return report","size_bytes":22017},"test_template_fixes.py":{"content":"#!/usr/bin/env python3\n\"\"\"Test the template library fixes\"\"\"\n\nimport json\nimport os\nfrom pathlib import Path\nfrom template_manager import TemplateManager\nimport email_file_generator as efg\n\ndef test_template_manager():\n    \"\"\"Test the template manager functionality\"\"\"\n    print(\"Testing Template Manager Fixes...\")\n    \n    # Initialize template manager\n    tm = TemplateManager(\"test_templates\")\n    \n    # Test 1: Save a new template\n    print(\"\\n1. Testing save_template (new template)...\")\n    template_text = \"\"\"Dear [FirstName] [LastName],\n\nThank you for your interest in our [Product] product.\n\n[Conditional:Premium]\n\nBest regards,\n[SenderName]\"\"\"\n    \n    result = tm.save_template(\n        name=\"Test Template\",\n        template_text=template_text,\n        description=\"A test template for verification\"\n    )\n    print(f\"   Result: {result['message']}\")\n    print(f\"   Overwrite: {result.get('overwrite', False)}\")\n    assert result['success'], \"Failed to save new template\"\n    assert not result.get('overwrite', False), \"Should not be an overwrite for new template\"\n    \n    # Test 2: Save same template again (overwrite check)\n    print(\"\\n2. Testing save_template (overwrite existing)...\")\n    result = tm.save_template(\n        name=\"Test Template\",\n        template_text=template_text + \"\\nUpdated!\",\n        description=\"Updated test template\"\n    )\n    print(f\"   Result: {result['message']}\")\n    print(f\"   Overwrite: {result.get('overwrite', False)}\")\n    assert result['success'], \"Failed to overwrite template\"\n    assert result.get('overwrite', False), \"Should be an overwrite for existing template\"\n    \n    # Test 3: Load template and verify variables are extracted correctly\n    print(\"\\n3. Testing load_template and variable extraction...\")\n    result = tm.load_template(\"test_template.json\")\n    assert result['success'], \"Failed to load template\"\n    \n    loaded_data = result['data']\n    loaded_text = loaded_data['template_text']\n    \n    # Recompute variables from loaded text (as done in app.py)\n    recomputed_vars = efg.extract_variables(loaded_text)\n    stored_vars = loaded_data.get('variables', [])\n    \n    print(f\"   Stored variables: {stored_vars}\")\n    print(f\"   Recomputed variables: {recomputed_vars}\")\n    \n    # Variables should be properly extracted (without Conditional: prefix)\n    expected_vars = ['FirstName', 'LastName', 'Product', 'SenderName']\n    for var in expected_vars:\n        assert var in recomputed_vars, f\"Variable {var} not found in recomputed variables\"\n    \n    # Verify conditional keys are extracted\n    conditional_keys = loaded_data.get('conditional_keys', [])\n    print(f\"   Conditional keys: {conditional_keys}\")\n    assert 'Premium' in conditional_keys, \"Conditional key 'Premium' not found\"\n    \n    # Test 4: Export template\n    print(\"\\n4. Testing export_template...\")\n    export_path = Path(\"test_templates\") / \"exported_template.json\"\n    result = tm.export_template(\"test_template.json\", str(export_path))\n    print(f\"   Result: {result['message']}\")\n    assert result['success'], \"Failed to export template\"\n    assert export_path.exists(), \"Exported file does not exist\"\n    \n    # Verify exported content\n    with open(export_path, 'r') as f:\n        exported_data = json.load(f)\n    assert exported_data['name'] == \"Test Template\", \"Exported template name mismatch\"\n    \n    # Test 5: List templates\n    print(\"\\n5. Testing list_templates...\")\n    templates = tm.list_templates()\n    print(f\"   Found {len(templates)} template(s)\")\n    assert len(templates) > 0, \"No templates found\"\n    \n    for template in templates:\n        print(f\"   - {template['name']}: {template['variable_count']} vars, conditionals: {template['has_conditionals']}\")\n    \n    # Test 6: Delete template\n    print(\"\\n6. Testing delete_template...\")\n    result = tm.delete_template(\"test_template.json\")\n    print(f\"   Result: {result['message']}\")\n    assert result['success'], \"Failed to delete template\"\n    \n    # Cleanup\n    print(\"\\n7. Cleaning up test files...\")\n    if export_path.exists():\n        export_path.unlink()\n    \n    # Remove test directory if empty\n    test_dir = Path(\"test_templates\")\n    if test_dir.exists() and not any(test_dir.iterdir()):\n        test_dir.rmdir()\n    \n    print(\"\\n‚úÖ All tests passed successfully!\")\n    return True\n\nif __name__ == \"__main__\":\n    try:\n        test_template_manager()\n    except AssertionError as e:\n        print(f\"\\n‚ùå Test failed: {e}\")\n        exit(1)\n    except Exception as e:\n        print(f\"\\n‚ùå Unexpected error: {e}\")\n        import traceback\n        traceback.print_exc()\n        exit(1)","size_bytes":4622}},"version":2}